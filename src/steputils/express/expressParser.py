# Generated from D:/Source/steputils/docs/schema\express.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00a3")
        buf.write("\u05a4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092")
        buf.write("\t\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095")
        buf.write("\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099")
        buf.write("\t\u0099\4\u009a\t\u009a\4\u009b\t\u009b\4\u009c\t\u009c")
        buf.write("\4\u009d\t\u009d\4\u009e\t\u009e\4\u009f\t\u009f\4\u00a0")
        buf.write("\t\u00a0\4\u00a1\t\u00a1\4\u00a2\t\u00a2\4\u00a3\t\u00a3")
        buf.write("\4\u00a4\t\u00a4\4\u00a5\t\u00a5\4\u00a6\t\u00a6\4\u00a7")
        buf.write("\t\u00a7\4\u00a8\t\u00a8\4\u00a9\t\u00a9\4\u00aa\t\u00aa")
        buf.write("\4\u00ab\t\u00ab\4\u00ac\t\u00ac\3\2\3\2\3\2\5\2\u015c")
        buf.write("\n\2\3\2\3\2\3\2\3\2\5\2\u0162\n\2\3\2\7\2\u0165\n\2\f")
        buf.write("\2\16\2\u0168\13\2\3\2\3\2\3\3\3\3\3\4\3\4\3\4\3\4\7\4")
        buf.write("\u0172\n\4\f\4\16\4\u0175\13\4\3\4\3\4\3\5\3\5\3\5\5\5")
        buf.write("\u017c\n\5\3\5\3\5\3\5\3\6\3\6\3\7\3\7\3\b\3\b\3\b\3\b")
        buf.write("\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\5\t\u0193\n\t")
        buf.write("\3\n\3\n\3\n\3\n\5\n\u0199\n\n\3\n\5\n\u019c\n\n\3\n\3")
        buf.write("\n\3\13\3\13\3\13\3\13\3\13\5\13\u01a5\n\13\3\13\3\13")
        buf.write("\3\f\3\f\3\r\7\r\u01ac\n\r\f\r\16\r\u01af\13\r\3\r\7\r")
        buf.write("\u01b2\n\r\f\r\16\r\u01b5\13\r\3\r\7\r\u01b8\n\r\f\r\16")
        buf.write("\r\u01bb\13\r\3\16\3\16\3\17\3\17\5\17\u01c1\n\17\3\17")
        buf.write("\3\17\3\17\3\20\3\20\3\20\3\20\3\20\5\20\u01cb\n\20\5")
        buf.write("\20\u01cd\n\20\3\21\3\21\3\22\3\22\3\23\3\23\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\3\25\3\25\3\25\7\25\u01de\n\25\f")
        buf.write("\25\16\25\u01e1\13\25\3\25\3\25\3\25\3\26\7\26\u01e7\n")
        buf.write("\26\f\26\16\26\u01ea\13\26\3\26\5\26\u01ed\n\26\3\27\3")
        buf.write("\27\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\31\3\31\3\31")
        buf.write("\3\31\3\31\7\31\u01fd\n\31\f\31\16\31\u0200\13\31\3\31")
        buf.write("\3\31\3\32\3\32\3\32\3\32\5\32\u0208\n\32\3\33\3\33\3")
        buf.write("\33\3\33\5\33\u020e\n\33\3\34\3\34\3\34\3\34\3\34\3\35")
        buf.write("\3\35\3\35\5\35\u0218\n\35\3\35\5\35\u021b\n\35\3\35\3")
        buf.write("\35\3\36\3\36\3\36\3\36\3\37\3\37\3\37\5\37\u0226\n\37")
        buf.write("\3\37\3\37\3 \3 \3 \3 \3!\3!\3!\3!\5!\u0232\n!\3\"\3\"")
        buf.write("\7\"\u0236\n\"\f\"\16\"\u0239\13\"\3\"\3\"\3\"\3#\3#\3")
        buf.write("$\3$\3$\3$\3$\3$\3%\3%\3&\3&\5&\u024a\n&\3\'\3\'\3\'\3")
        buf.write("\'\5\'\u0250\n\'\3(\3(\6(\u0254\n(\r(\16(\u0255\3)\3)")
        buf.write("\3)\3)\3)\3)\3*\3*\5*\u0260\n*\3+\3+\3+\3+\3+\3+\3,\3")
        buf.write(",\3,\3,\3-\3-\3-\3-\3.\3.\3.\3.\6.\u0274\n.\r.\16.\u0275")
        buf.write("\3/\3/\3/\3/\3/\3/\3/\3/\5/\u0280\n/\3\60\3\60\3\60\7")
        buf.write("\60\u0285\n\60\f\60\16\60\u0288\13\60\3\60\3\60\3\61\3")
        buf.write("\61\3\61\3\62\3\62\3\62\3\62\3\62\3\63\3\63\3\64\3\64")
        buf.write("\3\64\3\64\3\64\3\65\3\65\3\65\3\65\3\65\7\65\u02a0\n")
        buf.write("\65\f\65\16\65\u02a3\13\65\5\65\u02a5\n\65\3\65\3\65\3")
        buf.write("\66\3\66\3\67\3\67\38\38\38\58\u02b0\n8\38\38\39\39\3")
        buf.write("9\39\39\39\3:\3:\3:\7:\u02bd\n:\f:\16:\u02c0\13:\3;\3")
        buf.write(";\3;\3<\3<\3<\7<\u02c8\n<\f<\16<\u02cb\13<\3<\3<\5<\u02cf")
        buf.write("\n<\3<\3<\3<\3=\3=\5=\u02d6\n=\3>\3>\3>\5>\u02db\n>\3")
        buf.write(">\3>\3>\3?\3?\3?\5?\u02e3\n?\3@\3@\3@\5@\u02e8\n@\3A\3")
        buf.write("A\3A\7A\u02ed\nA\fA\16A\u02f0\13A\3A\3A\3A\3B\3B\3B\3")
        buf.write("B\7B\u02f9\nB\fB\16B\u02fc\13B\3B\3B\3C\3C\3D\3D\3D\7")
        buf.write("D\u0305\nD\fD\16D\u0308\13D\3D\3D\3D\3D\3E\3E\5E\u0310")
        buf.write("\nE\3F\3F\5F\u0314\nF\3F\3F\3G\3G\3G\3G\3G\3G\3H\3H\3")
        buf.write("H\5H\u0321\nH\3I\3I\3I\3I\3I\3I\5I\u0329\nI\3I\3I\3I\3")
        buf.write("J\3J\3J\5J\u0331\nJ\3K\3K\3K\5K\u0336\nK\3L\3L\3L\3L\7")
        buf.write("L\u033c\nL\fL\16L\u033f\13L\3L\3L\3M\3M\3M\3M\3M\5M\u0348")
        buf.write("\nM\3N\3N\3O\3O\3O\3O\3O\3O\3O\5O\u0353\nO\3P\3P\3P\3")
        buf.write("P\5P\u0359\nP\3Q\3Q\3R\3R\5R\u035f\nR\3S\3S\3S\3S\3S\3")
        buf.write("S\3S\3S\3T\3T\5T\u036b\nT\3U\3U\7U\u036f\nU\fU\16U\u0372")
        buf.write("\13U\3V\3V\3V\3V\3V\3V\3V\3W\3W\3W\3W\3W\3W\3W\3X\3X\5")
        buf.write("X\u0384\nX\3X\5X\u0387\nX\3X\3X\3Y\3Y\3Z\3Z\5Z\u038f\n")
        buf.write("Z\3Z\3Z\5Z\u0393\nZ\3Z\3Z\3[\3[\3[\3[\3[\3[\3[\5[\u039e")
        buf.write("\n[\3\\\3\\\7\\\u03a2\n\\\f\\\16\\\u03a5\13\\\3\\\3\\")
        buf.write("\3\\\3]\5]\u03ab\n]\3]\5]\u03ae\n]\3^\3^\3^\7^\u03b3\n")
        buf.write("^\f^\16^\u03b6\13^\3^\3^\3^\5^\u03bb\n^\3^\5^\u03be\n")
        buf.write("^\3^\3^\3_\3_\3`\3`\3a\3a\5a\u03c8\na\3b\3b\3c\3c\3d\3")
        buf.write("d\3e\3e\3e\3e\3f\3f\3g\3g\3h\3h\3i\3i\3j\3j\3j\3k\3k\3")
        buf.write("l\3l\3l\3l\3l\3l\3m\3m\3m\5m\u03ea\nm\3m\3m\3n\3n\5n\u03f0")
        buf.write("\nn\3n\3n\3o\7o\u03f5\no\fo\16o\u03f8\13o\3o\5o\u03fb")
        buf.write("\no\3o\5o\u03fe\no\3p\3p\5p\u0402\np\3q\3q\3q\7q\u0407")
        buf.write("\nq\fq\16q\u040a\13q\3r\3r\3r\3r\3s\3s\3s\3s\3s\3s\3s")
        buf.write("\3t\3t\3u\3u\3u\3u\3u\5u\u041e\nu\3v\3v\3v\3v\5v\u0424")
        buf.write("\nv\3v\3v\3w\3w\3x\3x\5x\u042c\nx\3y\3y\3z\5z\u0431\n")
        buf.write("z\3z\5z\u0434\nz\3z\5z\u0437\nz\3{\3{\3{\3{\3{\3{\3{\3")
        buf.write("|\3|\3}\3}\3}\3}\3}\5}\u0447\n}\3}\3}\3}\3}\3}\5}\u044e")
        buf.write("\n}\3}\5}\u0451\n}\3~\3~\3~\5~\u0456\n~\3~\3~\3~\3~\3")
        buf.write("\177\3\177\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080")
        buf.write("\3\u0081\3\u0081\3\u0081\3\u0081\7\u0081\u0468\n\u0081")
        buf.write("\f\u0081\16\u0081\u046b\13\u0081\3\u0081\3\u0081\3\u0082")
        buf.write("\7\u0082\u0470\n\u0082\f\u0082\16\u0082\u0473\13\u0082")
        buf.write("\3\u0082\5\u0082\u0476\n\u0082\3\u0082\3\u0082\7\u0082")
        buf.write("\u047a\n\u0082\f\u0082\16\u0082\u047d\13\u0082\3\u0083")
        buf.write("\3\u0083\3\u0083\3\u0083\3\u0083\3\u0083\3\u0083\3\u0084")
        buf.write("\3\u0084\3\u0085\3\u0085\3\u0086\3\u0086\3\u0086\3\u0086")
        buf.write("\3\u0086\3\u0087\3\u0087\3\u0087\7\u0087\u0492\n\u0087")
        buf.write("\f\u0087\16\u0087\u0495\13\u0087\3\u0088\3\u0088\3\u0088")
        buf.write("\3\u0088\3\u0088\3\u0089\3\u0089\3\u0089\7\u0089\u049f")
        buf.write("\n\u0089\f\u0089\16\u0089\u04a2\13\u0089\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\5\u008a\u04b0\n\u008a\3\u008b")
        buf.write("\3\u008b\3\u008b\3\u008b\3\u008b\3\u008b\3\u008b\5\u008b")
        buf.write("\u04b9\n\u008b\3\u008c\3\u008c\3\u008c\3\u008d\3\u008d")
        buf.write("\3\u008e\3\u008e\3\u008f\3\u008f\3\u0090\3\u0090\3\u0090")
        buf.write("\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090")
        buf.write("\3\u0090\5\u0090\u04cf\n\u0090\3\u0091\3\u0091\7\u0091")
        buf.write("\u04d3\n\u0091\f\u0091\16\u0091\u04d6\13\u0091\3\u0092")
        buf.write("\3\u0092\3\u0092\3\u0092\3\u0092\5\u0092\u04dd\n\u0092")
        buf.write("\5\u0092\u04df\n\u0092\3\u0093\5\u0093\u04e2\n\u0093\3")
        buf.write("\u0093\5\u0093\u04e5\n\u0093\3\u0094\3\u0094\3\u0094\3")
        buf.write("\u0094\3\u0094\3\u0094\3\u0094\3\u0094\3\u0094\3\u0094")
        buf.write("\5\u0094\u04f1\n\u0094\3\u0095\3\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0095\7\u0095\u04f9\n\u0095\f\u0095\16\u0095")
        buf.write("\u04fc\13\u0095\3\u0095\3\u0095\3\u0096\3\u0096\3\u0096")
        buf.write("\5\u0096\u0503\n\u0096\3\u0096\3\u0096\3\u0096\3\u0096")
        buf.write("\3\u0096\3\u0096\5\u0096\u050b\n\u0096\3\u0097\3\u0097")
        buf.write("\3\u0097\7\u0097\u0510\n\u0097\f\u0097\16\u0097\u0513")
        buf.write("\13\u0097\3\u0098\3\u0098\3\u0098\3\u0098\3\u0098\3\u0098")
        buf.write("\5\u0098\u051b\n\u0098\3\u0099\3\u0099\7\u0099\u051f\n")
        buf.write("\u0099\f\u0099\16\u0099\u0522\13\u0099\3\u009a\3\u009a")
        buf.write("\3\u009a\7\u009a\u0527\n\u009a\f\u009a\16\u009a\u052a")
        buf.write("\13\u009a\3\u009a\3\u009a\3\u009a\3\u009a\5\u009a\u0530")
        buf.write("\n\u009a\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\5\u009b")
        buf.write("\u0537\n\u009b\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c")
        buf.write("\3\u009d\3\u009d\3\u009e\3\u009e\3\u009f\3\u009f\3\u00a0")
        buf.write("\3\u00a0\3\u00a0\3\u00a0\3\u00a0\5\u00a0\u0549\n\u00a0")
        buf.write("\3\u00a1\3\u00a1\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\7\u00a2\u0552\n\u00a2\f\u00a2\16\u00a2\u0555\13\u00a2")
        buf.write("\3\u00a3\3\u00a3\3\u00a3\3\u00a3\3\u00a3\3\u00a3\7\u00a3")
        buf.write("\u055d\n\u00a3\f\u00a3\16\u00a3\u0560\13\u00a3\3\u00a4")
        buf.write("\3\u00a4\3\u00a4\3\u00a5\3\u00a5\3\u00a5\3\u00a5\5\u00a5")
        buf.write("\u0569\n\u00a5\3\u00a5\3\u00a5\3\u00a6\3\u00a6\3\u00a6")
        buf.write("\3\u00a6\7\u00a6\u0571\n\u00a6\f\u00a6\16\u00a6\u0574")
        buf.write("\13\u00a6\3\u00a6\3\u00a6\3\u00a7\3\u00a7\3\u00a8\3\u00a8")
        buf.write("\3\u00a8\3\u00a9\3\u00a9\3\u00a9\3\u00a9\7\u00a9\u0581")
        buf.write("\n\u00a9\f\u00a9\16\u00a9\u0584\13\u00a9\3\u00a9\3\u00a9")
        buf.write("\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa")
        buf.write("\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa")
        buf.write("\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa")
        buf.write("\5\u00aa\u059d\n\u00aa\3\u00ab\3\u00ab\3\u00ab\3\u00ac")
        buf.write("\3\u00ac\3\u00ac\2\2\u00ad\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\")
        buf.write("^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a")
        buf.write("\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c")
        buf.write("\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae")
        buf.write("\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0")
        buf.write("\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2")
        buf.write("\u00d4\u00d6\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4")
        buf.write("\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6")
        buf.write("\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108")
        buf.write("\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a")
        buf.write("\u011c\u011e\u0120\u0122\u0124\u0126\u0128\u012a\u012c")
        buf.write("\u012e\u0130\u0132\u0134\u0136\u0138\u013a\u013c\u013e")
        buf.write("\u0140\u0142\u0144\u0146\u0148\u014a\u014c\u014e\u0150")
        buf.write("\u0152\u0154\u0156\2\r\3\2\u0096\u0097\5\2\21\30XX]]\4")
        buf.write("\2\21\21\23\23\4\2//}}\5\2\36\37nn\u0094\u0094\6\2  \67")
        buf.write("\67pp||\23\2$$&&-.\62\6288LMQQUV\\\\aeijxx~\177\u0081")
        buf.write("\u0081\u0085\u0085\u008a\u008a\u008f\u0090\4\2YYuu\3\2")
        buf.write(")*\6\2!#))::ff\4\2\36\37gg\2\u05ab\2\u0158\3\2\2\2\4\u016b")
        buf.write("\3\2\2\2\6\u016d\3\2\2\2\b\u0178\3\2\2\2\n\u0180\3\2\2")
        buf.write("\2\f\u0182\3\2\2\2\16\u0184\3\2\2\2\20\u0192\3\2\2\2\22")
        buf.write("\u0194\3\2\2\2\24\u019f\3\2\2\2\26\u01a8\3\2\2\2\30\u01ad")
        buf.write("\3\2\2\2\32\u01bc\3\2\2\2\34\u01be\3\2\2\2\36\u01c5\3")
        buf.write("\2\2\2 \u01ce\3\2\2\2\"\u01d0\3\2\2\2$\u01d2\3\2\2\2&")
        buf.write("\u01d4\3\2\2\2(\u01da\3\2\2\2*\u01e8\3\2\2\2,\u01ee\3")
        buf.write("\2\2\2.\u01f0\3\2\2\2\60\u01f7\3\2\2\2\62\u0207\3\2\2")
        buf.write("\2\64\u020d\3\2\2\2\66\u020f\3\2\2\28\u0214\3\2\2\2:\u021e")
        buf.write("\3\2\2\2<\u0222\3\2\2\2>\u0229\3\2\2\2@\u0231\3\2\2\2")
        buf.write("B\u0233\3\2\2\2D\u023d\3\2\2\2F\u023f\3\2\2\2H\u0245\3")
        buf.write("\2\2\2J\u0249\3\2\2\2L\u024f\3\2\2\2N\u0251\3\2\2\2P\u0257")
        buf.write("\3\2\2\2R\u025f\3\2\2\2T\u0261\3\2\2\2V\u0267\3\2\2\2")
        buf.write("X\u026b\3\2\2\2Z\u026f\3\2\2\2\\\u027f\3\2\2\2^\u0281")
        buf.write("\3\2\2\2`\u028b\3\2\2\2b\u028e\3\2\2\2d\u0293\3\2\2\2")
        buf.write("f\u0295\3\2\2\2h\u029a\3\2\2\2j\u02a8\3\2\2\2l\u02aa\3")
        buf.write("\2\2\2n\u02af\3\2\2\2p\u02b3\3\2\2\2r\u02b9\3\2\2\2t\u02c1")
        buf.write("\3\2\2\2v\u02c4\3\2\2\2x\u02d5\3\2\2\2z\u02d7\3\2\2\2")
        buf.write("|\u02df\3\2\2\2~\u02e4\3\2\2\2\u0080\u02e9\3\2\2\2\u0082")
        buf.write("\u02f4\3\2\2\2\u0084\u02ff\3\2\2\2\u0086\u0301\3\2\2\2")
        buf.write("\u0088\u030f\3\2\2\2\u008a\u0313\3\2\2\2\u008c\u0317\3")
        buf.write("\2\2\2\u008e\u031d\3\2\2\2\u0090\u0322\3\2\2\2\u0092\u032d")
        buf.write("\3\2\2\2\u0094\u0332\3\2\2\2\u0096\u0337\3\2\2\2\u0098")
        buf.write("\u0347\3\2\2\2\u009a\u0349\3\2\2\2\u009c\u034b\3\2\2\2")
        buf.write("\u009e\u0354\3\2\2\2\u00a0\u035a\3\2\2\2\u00a2\u035e\3")
        buf.write("\2\2\2\u00a4\u0360\3\2\2\2\u00a6\u036a\3\2\2\2\u00a8\u036c")
        buf.write("\3\2\2\2\u00aa\u0373\3\2\2\2\u00ac\u037a\3\2\2\2\u00ae")
        buf.write("\u0386\3\2\2\2\u00b0\u038a\3\2\2\2\u00b2\u038c\3\2\2\2")
        buf.write("\u00b4\u039d\3\2\2\2\u00b6\u039f\3\2\2\2\u00b8\u03aa\3")
        buf.write("\2\2\2\u00ba\u03af\3\2\2\2\u00bc\u03c1\3\2\2\2\u00be\u03c3")
        buf.write("\3\2\2\2\u00c0\u03c7\3\2\2\2\u00c2\u03c9\3\2\2\2\u00c4")
        buf.write("\u03cb\3\2\2\2\u00c6\u03cd\3\2\2\2\u00c8\u03cf\3\2\2\2")
        buf.write("\u00ca\u03d3\3\2\2\2\u00cc\u03d5\3\2\2\2\u00ce\u03d7\3")
        buf.write("\2\2\2\u00d0\u03d9\3\2\2\2\u00d2\u03db\3\2\2\2\u00d4\u03de")
        buf.write("\3\2\2\2\u00d6\u03e0\3\2\2\2\u00d8\u03e6\3\2\2\2\u00da")
        buf.write("\u03ef\3\2\2\2\u00dc\u03f6\3\2\2\2\u00de\u0401\3\2\2\2")
        buf.write("\u00e0\u0408\3\2\2\2\u00e2\u040b\3\2\2\2\u00e4\u040f\3")
        buf.write("\2\2\2\u00e6\u0416\3\2\2\2\u00e8\u0418\3\2\2\2\u00ea\u041f")
        buf.write("\3\2\2\2\u00ec\u0427\3\2\2\2\u00ee\u042b\3\2\2\2\u00f0")
        buf.write("\u042d\3\2\2\2\u00f2\u0430\3\2\2\2\u00f4\u0438\3\2\2\2")
        buf.write("\u00f6\u043f\3\2\2\2\u00f8\u0450\3\2\2\2\u00fa\u0452\3")
        buf.write("\2\2\2\u00fc\u045b\3\2\2\2\u00fe\u045d\3\2\2\2\u0100\u0463")
        buf.write("\3\2\2\2\u0102\u0471\3\2\2\2\u0104\u047e\3\2\2\2\u0106")
        buf.write("\u0485\3\2\2\2\u0108\u0487\3\2\2\2\u010a\u0489\3\2\2\2")
        buf.write("\u010c\u048e\3\2\2\2\u010e\u0496\3\2\2\2\u0110\u049b\3")
        buf.write("\2\2\2\u0112\u04af\3\2\2\2\u0114\u04b8\3\2\2\2\u0116\u04ba")
        buf.write("\3\2\2\2\u0118\u04bd\3\2\2\2\u011a\u04bf\3\2\2\2\u011c")
        buf.write("\u04c1\3\2\2\2\u011e\u04ce\3\2\2\2\u0120\u04d0\3\2\2\2")
        buf.write("\u0122\u04d7\3\2\2\2\u0124\u04e1\3\2\2\2\u0126\u04f0\3")
        buf.write("\2\2\2\u0128\u04f2\3\2\2\2\u012a\u050a\3\2\2\2\u012c\u050c")
        buf.write("\3\2\2\2\u012e\u051a\3\2\2\2\u0130\u051c\3\2\2\2\u0132")
        buf.write("\u052f\3\2\2\2\u0134\u0531\3\2\2\2\u0136\u0538\3\2\2\2")
        buf.write("\u0138\u053d\3\2\2\2\u013a\u053f\3\2\2\2\u013c\u0541\3")
        buf.write("\2\2\2\u013e\u0548\3\2\2\2\u0140\u054a\3\2\2\2\u0142\u054c")
        buf.write("\3\2\2\2\u0144\u0556\3\2\2\2\u0146\u0561\3\2\2\2\u0148")
        buf.write("\u0564\3\2\2\2\u014a\u056c\3\2\2\2\u014c\u0577\3\2\2\2")
        buf.write("\u014e\u0579\3\2\2\2\u0150\u057c\3\2\2\2\u0152\u059c\3")
        buf.write("\2\2\2\u0154\u059e\3\2\2\2\u0156\u05a1\3\2\2\2\u0158\u015b")
        buf.write("\7\3\2\2\u0159\u015a\7\4\2\2\u015a\u015c\7\u0096\2\2\u015b")
        buf.write("\u0159\3\2\2\2\u015b\u015c\3\2\2\2\u015c\u015d\3\2\2\2")
        buf.write("\u015d\u0166\5\u00ccg\2\u015e\u0161\7\5\2\2\u015f\u0160")
        buf.write("\7\4\2\2\u0160\u0162\7\u0096\2\2\u0161\u015f\3\2\2\2\u0161")
        buf.write("\u0162\3\2\2\2\u0162\u0163\3\2\2\2\u0163\u0165\5\u00cc")
        buf.write("g\2\u0164\u015e\3\2\2\2\u0165\u0168\3\2\2\2\u0166\u0164")
        buf.write("\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u0169\3\2\2\2\u0168")
        buf.write("\u0166\3\2\2\2\u0169\u016a\7\6\2\2\u016a\3\3\2\2\2\u016b")
        buf.write("\u016c\5|?\2\u016c\5\3\2\2\2\u016d\u016e\7\7\2\2\u016e")
        buf.write("\u0173\5\\/\2\u016f\u0170\7\5\2\2\u0170\u0172\5\\/\2\u0171")
        buf.write("\u016f\3\2\2\2\u0172\u0175\3\2\2\2\u0173\u0171\3\2\2\2")
        buf.write("\u0173\u0174\3\2\2\2\u0174\u0176\3\2\2\2\u0175\u0173\3")
        buf.write("\2\2\2\u0176\u0177\7\b\2\2\u0177\7\3\2\2\2\u0178\u017b")
        buf.write("\7\'\2\2\u0179\u017a\7\t\2\2\u017a\u017c\5\u013a\u009e")
        buf.write("\2\u017b\u0179\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u017d")
        buf.write("\3\2\2\2\u017d\u017e\7k\2\2\u017e\u017f\5\20\t\2\u017f")
        buf.write("\t\3\2\2\2\u0180\u0181\7\u0096\2\2\u0181\13\3\2\2\2\u0182")
        buf.write("\u0183\7\u0096\2\2\u0183\r\3\2\2\2\u0184\u0185\7(\2\2")
        buf.write("\u0185\u0186\5\n\6\2\u0186\u0187\7P\2\2\u0187\u0188\5")
        buf.write("\u0152\u00aa\2\u0188\u0189\7\n\2\2\u0189\u018a\5\u0120")
        buf.write("\u0091\2\u018a\u018b\7=\2\2\u018b\u018c\7\n\2\2\u018c")
        buf.write("\17\3\2\2\2\u018d\u0193\5\b\5\2\u018e\u0193\5@!\2\u018f")
        buf.write("\u0193\5\u0114\u008b\2\u0190\u0193\5\u00c0a\2\u0191\u0193")
        buf.write("\5\u00dep\2\u0192\u018d\3\2\2\2\u0192\u018e\3\2\2\2\u0192")
        buf.write("\u018f\3\2\2\2\u0192\u0190\3\2\2\2\u0192\u0191\3\2\2\2")
        buf.write("\u0193\21\3\2\2\2\u0194\u0195\7+\2\2\u0195\u0196\5&\24")
        buf.write("\2\u0196\u0198\7k\2\2\u0197\u0199\7m\2\2\u0198\u0197\3")
        buf.write("\2\2\2\u0198\u0199\3\2\2\2\u0199\u019b\3\2\2\2\u019a\u019c")
        buf.write("\7\u008b\2\2\u019b\u019a\3\2\2\2\u019b\u019c\3\2\2\2\u019c")
        buf.write("\u019d\3\2\2\2\u019d\u019e\5\64\33\2\u019e\23\3\2\2\2")
        buf.write("\u019f\u01a0\5\u0152\u00aa\2\u01a0\u01a4\7\13\2\2\u01a1")
        buf.write("\u01a5\5|?\2\u01a2\u01a5\5V,\2\u01a3\u01a5\7\f\2\2\u01a4")
        buf.write("\u01a1\3\2\2\2\u01a4\u01a2\3\2\2\2\u01a4\u01a3\3\2\2\2")
        buf.write("\u01a5\u01a6\3\2\2\2\u01a6\u01a7\7\n\2\2\u01a7\25\3\2")
        buf.write("\2\2\u01a8\u01a9\t\2\2\2\u01a9\27\3\2\2\2\u01aa\u01ac")
        buf.write("\5x=\2\u01ab\u01aa\3\2\2\2\u01ac\u01af\3\2\2\2\u01ad\u01ab")
        buf.write("\3\2\2\2\u01ad\u01ae\3\2\2\2\u01ae\u01b3\3\2\2\2\u01af")
        buf.write("\u01ad\3\2\2\2\u01b0\u01b2\5N(\2\u01b1\u01b0\3\2\2\2\u01b2")
        buf.write("\u01b5\3\2\2\2\u01b3\u01b1\3\2\2\2\u01b3\u01b4\3\2\2\2")
        buf.write("\u01b4\u01b9\3\2\2\2\u01b5\u01b3\3\2\2\2\u01b6\u01b8\5")
        buf.write("\u00a8U\2\u01b7\u01b6\3\2\2\2\u01b8\u01bb\3\2\2\2\u01b9")
        buf.write("\u01b7\3\2\2\2\u01b9\u01ba\3\2\2\2\u01ba\31\3\2\2\2\u01bb")
        buf.write("\u01b9\3\2\2\2\u01bc\u01bd\t\2\2\2\u01bd\33\3\2\2\2\u01be")
        buf.write("\u01c0\7/\2\2\u01bf\u01c1\5&\24\2\u01c0\u01bf\3\2\2\2")
        buf.write("\u01c0\u01c1\3\2\2\2\u01c1\u01c2\3\2\2\2\u01c2\u01c3\7")
        buf.write("k\2\2\u01c3\u01c4\5\64\33\2\u01c4\35\3\2\2\2\u01c5\u01cc")
        buf.write("\7\61\2\2\u01c6\u01c7\7\3\2\2\u01c7\u01c8\5\u0156\u00ac")
        buf.write("\2\u01c8\u01ca\7\6\2\2\u01c9\u01cb\7O\2\2\u01ca\u01c9")
        buf.write("\3\2\2\2\u01ca\u01cb\3\2\2\2\u01cb\u01cd\3\2\2\2\u01cc")
        buf.write("\u01c6\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cd\37\3\2\2\2\u01ce")
        buf.write("\u01cf\7\63\2\2\u01cf!\3\2\2\2\u01d0\u01d1\5\u00c4c\2")
        buf.write("\u01d1#\3\2\2\2\u01d2\u01d3\5\u00c4c\2\u01d3%\3\2\2\2")
        buf.write("\u01d4\u01d5\7\7\2\2\u01d5\u01d6\5\"\22\2\u01d6\u01d7")
        buf.write("\7\t\2\2\u01d7\u01d8\5$\23\2\u01d8\u01d9\7\b\2\2\u01d9")
        buf.write("\'\3\2\2\2\u01da\u01df\5,\27\2\u01db\u01dc\7\5\2\2\u01dc")
        buf.write("\u01de\5,\27\2\u01dd\u01db\3\2\2\2\u01de\u01e1\3\2\2\2")
        buf.write("\u01df\u01dd\3\2\2\2\u01df\u01e0\3\2\2\2\u01e0\u01e2\3")
        buf.write("\2\2\2\u01e1\u01df\3\2\2\2\u01e2\u01e3\7\t\2\2\u01e3\u01e4")
        buf.write("\5\u011e\u0090\2\u01e4)\3\2\2\2\u01e5\u01e7\5(\25\2\u01e6")
        buf.write("\u01e5\3\2\2\2\u01e7\u01ea\3\2\2\2\u01e8\u01e6\3\2\2\2")
        buf.write("\u01e8\u01e9\3\2\2\2\u01e9\u01ec\3\2\2\2\u01ea\u01e8\3")
        buf.write("\2\2\2\u01eb\u01ed\5\u00c8e\2\u01ec\u01eb\3\2\2\2\u01ec")
        buf.write("\u01ed\3\2\2\2\u01ed+\3\2\2\2\u01ee\u01ef\5|?\2\u01ef")
        buf.write("-\3\2\2\2\u01f0\u01f1\7\65\2\2\u01f1\u01f2\5\u0108\u0085")
        buf.write("\2\u01f2\u01f3\7k\2\2\u01f3\u01f4\5*\26\2\u01f4\u01f5")
        buf.write("\7>\2\2\u01f5\u01f6\7\n\2\2\u01f6/\3\2\2\2\u01f7\u01f8")
        buf.write("\7l\2\2\u01f8\u01f9\7\3\2\2\u01f9\u01fe\5\u012c\u0097")
        buf.write("\2\u01fa\u01fb\7\5\2\2\u01fb\u01fd\5\u012c\u0097\2\u01fc")
        buf.write("\u01fa\3\2\2\2\u01fd\u0200\3\2\2\2\u01fe\u01fc\3\2\2\2")
        buf.write("\u01fe\u01ff\3\2\2\2\u01ff\u0201\3\2\2\2\u0200\u01fe\3")
        buf.write("\2\2\2\u0201\u0202\7\6\2\2\u0202\61\3\2\2\2\u0203\u0208")
        buf.write("\5\22\n\2\u0204\u0208\5\34\17\2\u0205\u0208\5\u00b2Z\2")
        buf.write("\u0206\u0208\5\u010e\u0088\2\u0207\u0203\3\2\2\2\u0207")
        buf.write("\u0204\3\2\2\2\u0207\u0205\3\2\2\2\u0207\u0206\3\2\2\2")
        buf.write("\u0208\63\3\2\2\2\u0209\u020e\5\62\32\2\u020a\u020e\5")
        buf.write("\u00c0a\2\u020b\u020e\5\u0114\u008b\2\u020c\u020e\5\u008e")
        buf.write("H\2\u020d\u0209\3\2\2\2\u020d\u020a\3\2\2\2\u020d\u020b")
        buf.write("\3\2\2\2\u020d\u020c\3\2\2\2\u020e\65\3\2\2\2\u020f\u0210")
        buf.write("\7\60\2\2\u0210\u0211\5\u0120\u0091\2\u0211\u0212\7<\2")
        buf.write("\2\u0212\u0213\7\n\2\2\u0213\67\3\2\2\2\u0214\u0215\7")
        buf.write("+\2\2\u0215\u0217\7k\2\2\u0216\u0218\7m\2\2\u0217\u0216")
        buf.write("\3\2\2\2\u0217\u0218\3\2\2\2\u0218\u021a\3\2\2\2\u0219")
        buf.write("\u021b\7\u008b\2\2\u021a\u0219\3\2\2\2\u021a\u021b\3\2")
        buf.write("\2\2\u021b\u021c\3\2\2\2\u021c\u021d\5\20\t\2\u021d9\3")
        buf.write("\2\2\2\u021e\u021f\7/\2\2\u021f\u0220\7k\2\2\u0220\u0221")
        buf.write("\5\20\t\2\u0221;\3\2\2\2\u0222\u0223\7^\2\2\u0223\u0225")
        buf.write("\7k\2\2\u0224\u0226\7\u008b\2\2\u0225\u0224\3\2\2\2\u0225")
        buf.write("\u0226\3\2\2\2\u0226\u0227\3\2\2\2\u0227\u0228\5\20\t")
        buf.write("\2\u0228=\3\2\2\2\u0229\u022a\7}\2\2\u022a\u022b\7k\2")
        buf.write("\2\u022b\u022c\5\20\t\2\u022c?\3\2\2\2\u022d\u0232\58")
        buf.write("\35\2\u022e\u0232\5:\36\2\u022f\u0232\5<\37\2\u0230\u0232")
        buf.write("\5> \2\u0231\u022d\3\2\2\2\u0231\u022e\3\2\2\2\u0231\u022f")
        buf.write("\3\2\2\2\u0231\u0230\3\2\2\2\u0232A\3\2\2\2\u0233\u0237")
        buf.write("\7\66\2\2\u0234\u0236\5F$\2\u0235\u0234\3\2\2\2\u0236")
        buf.write("\u0239\3\2\2\2\u0237\u0235\3\2\2\2\u0237\u0238\3\2\2\2")
        buf.write("\u0238\u023a\3\2\2\2\u0239\u0237\3\2\2\2\u023a\u023b\7")
        buf.write("?\2\2\u023b\u023c\7\n\2\2\u023cC\3\2\2\2\u023d\u023e\7")
        buf.write("\u0096\2\2\u023eE\3\2\2\2\u023f\u0240\5H%\2\u0240\u0241")
        buf.write("\7\t\2\2\u0241\u0242\5\64\33\2\u0242\u0243\5\u009eP\2")
        buf.write("\u0243\u0244\7\n\2\2\u0244G\3\2\2\2\u0245\u0246\7\u0096")
        buf.write("\2\2\u0246I\3\2\2\2\u0247\u024a\5H%\2\u0248\u024a\5\u0118")
        buf.write("\u008d\2\u0249\u0247\3\2\2\2\u0249\u0248\3\2\2\2\u024a")
        buf.write("K\3\2\2\2\u024b\u0250\5b\62\2\u024c\u0250\5\u008cG\2\u024d")
        buf.write("\u0250\5\u00d6l\2\u024e\u0250\5\u0136\u009c\2\u024f\u024b")
        buf.write("\3\2\2\2\u024f\u024c\3\2\2\2\u024f\u024d\3\2\2\2\u024f")
        buf.write("\u024e\3\2\2\2\u0250M\3\2\2\2\u0251\u0253\79\2\2\u0252")
        buf.write("\u0254\5R*\2\u0253\u0252\3\2\2\2\u0254\u0255\3\2\2\2\u0255")
        buf.write("\u0253\3\2\2\2\u0255\u0256\3\2\2\2\u0256O\3\2\2\2\u0257")
        buf.write("\u0258\5\26\f\2\u0258\u0259\7\t\2\2\u0259\u025a\5\64\33")
        buf.write("\2\u025a\u025b\5\u009eP\2\u025b\u025c\7\n\2\2\u025cQ\3")
        buf.write("\2\2\2\u025d\u0260\5P)\2\u025e\u0260\5T+\2\u025f\u025d")
        buf.write("\3\2\2\2\u025f\u025e\3\2\2\2\u0260S\3\2\2\2\u0261\u0262")
        buf.write("\5\32\16\2\u0262\u0263\7\t\2\2\u0263\u0264\5\64\33\2\u0264")
        buf.write("\u0265\5\u009eP\2\u0265\u0266\7\n\2\2\u0266U\3\2\2\2\u0267")
        buf.write("\u0268\5|?\2\u0268\u0269\7\r\2\2\u0269\u026a\7\u0097\2")
        buf.write("\2\u026aW\3\2\2\2\u026b\u026c\5\u00b0Y\2\u026c\u026d\7")
        buf.write("\t\2\2\u026d\u026e\5\u00bc_\2\u026eY\3\2\2\2\u026f\u0273")
        buf.write("\7\u0092\2\2\u0270\u0271\5X-\2\u0271\u0272\7\n\2\2\u0272")
        buf.write("\u0274\3\2\2\2\u0273\u0270\3\2\2\2\u0274\u0275\3\2\2\2")
        buf.write("\u0275\u0273\3\2\2\2\u0275\u0276\3\2\2\2\u0276[\3\2\2")
        buf.write("\2\u0277\u0278\5|?\2\u0278\u0279\7\t\2\2\u0279\u027a\5")
        buf.write("\u00f6|\2\u027a\u0280\3\2\2\2\u027b\u0280\7\u00a0\2\2")
        buf.write("\u027c\u0280\7\u009b\2\2\u027d\u0280\5|?\2\u027e\u0280")
        buf.write("\5V,\2\u027f\u0277\3\2\2\2\u027f\u027b\3\2\2\2\u027f\u027c")
        buf.write("\3\2\2\2\u027f\u027d\3\2\2\2\u027f\u027e\3\2\2\2\u0280")
        buf.write("]\3\2\2\2\u0281\u0286\7\16\2\2\u0282\u0285\5^\60\2\u0283")
        buf.write("\u0285\5\u00f0y\2\u0284\u0282\3\2\2\2\u0284\u0283\3\2")
        buf.write("\2\2\u0285\u0288\3\2\2\2\u0286\u0284\3\2\2\2\u0286\u0287")
        buf.write("\3\2\2\2\u0287\u0289\3\2\2\2\u0288\u0286\3\2\2\2\u0289")
        buf.write("\u028a\7\17\2\2\u028a_\3\2\2\2\u028b\u028c\5\30\r\2\u028c")
        buf.write("\u028d\5\u00b8]\2\u028da\3\2\2\2\u028e\u028f\5f\64\2\u028f")
        buf.write("\u0290\5`\61\2\u0290\u0291\7@\2\2\u0291\u0292\7\n\2\2")
        buf.write("\u0292c\3\2\2\2\u0293\u0294\7\u0096\2\2\u0294e\3\2\2\2")
        buf.write("\u0295\u0296\7I\2\2\u0296\u0297\5d\63\2\u0297\u0298\5")
        buf.write("\u0124\u0093\2\u0298\u0299\7\n\2\2\u0299g\3\2\2\2\u029a")
        buf.write("\u029b\5j\66\2\u029b\u02a4\7\3\2\2\u029c\u02a1\5|?\2\u029d")
        buf.write("\u029e\7\5\2\2\u029e\u02a0\5|?\2\u029f\u029d\3\2\2\2\u02a0")
        buf.write("\u02a3\3\2\2\2\u02a1\u029f\3\2\2\2\u02a1\u02a2\3\2\2\2")
        buf.write("\u02a2\u02a5\3\2\2\2\u02a3\u02a1\3\2\2\2\u02a4\u029c\3")
        buf.write("\2\2\2\u02a4\u02a5\3\2\2\2\u02a5\u02a6\3\2\2\2\u02a6\u02a7")
        buf.write("\7\6\2\2\u02a7i\3\2\2\2\u02a8\u02a9\7\u0096\2\2\u02a9")
        buf.write("k\3\2\2\2\u02aa\u02ab\7\u0096\2\2\u02abm\3\2\2\2\u02ac")
        buf.write("\u02ad\5\u013c\u009f\2\u02ad\u02ae\7\20\2\2\u02ae\u02b0")
        buf.write("\3\2\2\2\u02af\u02ac\3\2\2\2\u02af\u02b0\3\2\2\2\u02b0")
        buf.write("\u02b1\3\2\2\2\u02b1\u02b2\5l\67\2\u02b2o\3\2\2\2\u02b3")
        buf.write("\u02b4\7J\2\2\u02b4\u02b5\7k\2\2\u02b5\u02b6\7\3\2\2\u02b6")
        buf.write("\u02b7\5r:\2\u02b7\u02b8\7\6\2\2\u02b8q\3\2\2\2\u02b9")
        buf.write("\u02be\5l\67\2\u02ba\u02bb\7\5\2\2\u02bb\u02bd\5l\67\2")
        buf.write("\u02bc\u02ba\3\2\2\2\u02bd\u02c0\3\2\2\2\u02be\u02bc\3")
        buf.write("\2\2\2\u02be\u02bf\3\2\2\2\u02bfs\3\2\2\2\u02c0\u02be")
        buf.write("\3\2\2\2\u02c1\u02c2\7K\2\2\u02c2\u02c3\7\n\2\2\u02c3")
        buf.write("u\3\2\2\2\u02c4\u02c9\5\26\f\2\u02c5\u02c6\7\5\2\2\u02c6")
        buf.write("\u02c8\5\26\f\2\u02c7\u02c5\3\2\2\2\u02c8\u02cb\3\2\2")
        buf.write("\2\u02c9\u02c7\3\2\2\2\u02c9\u02ca\3\2\2\2\u02ca\u02cc")
        buf.write("\3\2\2\2\u02cb\u02c9\3\2\2\2\u02cc\u02ce\7\t\2\2\u02cd")
        buf.write("\u02cf\7m\2\2\u02ce\u02cd\3\2\2\2\u02ce\u02cf\3\2\2\2")
        buf.write("\u02cf\u02d0\3\2\2\2\u02d0\u02d1\5\64\33\2\u02d1\u02d2")
        buf.write("\7\n\2\2\u02d2w\3\2\2\2\u02d3\u02d6\5v<\2\u02d4\u02d6")
        buf.write("\5z>\2\u02d5\u02d3\3\2\2\2\u02d5\u02d4\3\2\2\2\u02d6y")
        buf.write("\3\2\2\2\u02d7\u02d8\5\32\16\2\u02d8\u02da\7\t\2\2\u02d9")
        buf.write("\u02db\7m\2\2\u02da\u02d9\3\2\2\2\u02da\u02db\3\2\2\2")
        buf.write("\u02db\u02dc\3\2\2\2\u02dc\u02dd\5\64\33\2\u02dd\u02de")
        buf.write("\7\n\2\2\u02de{\3\2\2\2\u02df\u02e2\5\u0110\u0089\2\u02e0")
        buf.write("\u02e1\t\3\2\2\u02e1\u02e3\5\u0110\u0089\2\u02e2\u02e0")
        buf.write("\3\2\2\2\u02e2\u02e3\3\2\2\2\u02e3}\3\2\2\2\u02e4\u02e7")
        buf.write("\5\u0112\u008a\2\u02e5\u02e6\7\31\2\2\u02e6\u02e8\5\u0112")
        buf.write("\u008a\2\u02e7\u02e5\3\2\2\2\u02e7\u02e8\3\2\2\2\u02e8")
        buf.write("\177\3\2\2\2\u02e9\u02ee\5\u00caf\2\u02ea\u02eb\7\5\2")
        buf.write("\2\u02eb\u02ed\5\u00caf\2\u02ec\u02ea\3\2\2\2\u02ed\u02f0")
        buf.write("\3\2\2\2\u02ee\u02ec\3\2\2\2\u02ee\u02ef\3\2\2\2\u02ef")
        buf.write("\u02f1\3\2\2\2\u02f0\u02ee\3\2\2\2\u02f1\u02f2\7\t\2\2")
        buf.write("\u02f2\u02f3\5\u0088E\2\u02f3\u0081\3\2\2\2\u02f4\u02f5")
        buf.write("\7\3\2\2\u02f5\u02fa\5\u0080A\2\u02f6\u02f7\7\n\2\2\u02f7")
        buf.write("\u02f9\5\u0080A\2\u02f8\u02f6\3\2\2\2\u02f9\u02fc\3\2")
        buf.write("\2\2\u02fa\u02f8\3\2\2\2\u02fa\u02fb\3\2\2\2\u02fb\u02fd")
        buf.write("\3\2\2\2\u02fc\u02fa\3\2\2\2\u02fd\u02fe\7\6\2\2\u02fe")
        buf.write("\u0083\3\2\2\2\u02ff\u0300\7\u0096\2\2\u0300\u0085\3\2")
        buf.write("\2\2\u0301\u0302\7S\2\2\u0302\u0306\5\u0084C\2\u0303\u0305")
        buf.write("\5\u0082B\2\u0304\u0303\3\2\2\2\u0305\u0308\3\2\2\2\u0306")
        buf.write("\u0304\3\2\2\2\u0306\u0307\3\2\2\2\u0307\u0309\3\2\2\2")
        buf.write("\u0308\u0306\3\2\2\2\u0309\u030a\7\t\2\2\u030a\u030b\5")
        buf.write("\u0088E\2\u030b\u030c\7\n\2\2\u030c\u0087\3\2\2\2\u030d")
        buf.write("\u0310\5\20\t\2\u030e\u0310\5\62\32\2\u030f\u030d\3\2")
        buf.write("\2\2\u030f\u030e\3\2\2\2\u0310\u0089\3\2\2\2\u0311\u0314")
        buf.write("\5\u0084C\2\u0312\u0314\5\u011a\u008e\2\u0313\u0311\3")
        buf.write("\2\2\2\u0313\u0312\3\2\2\2\u0314\u0315\3\2\2\2\u0315\u0316")
        buf.write("\5\2\2\2\u0316\u008b\3\2\2\2\u0317\u0318\5\u0086D\2\u0318")
        buf.write("\u0319\5\u00dco\2\u0319\u031a\5\u0120\u0091\2\u031a\u031b")
        buf.write("\7A\2\2\u031b\u031c\7\n\2\2\u031c\u008d\3\2\2\2\u031d")
        buf.write("\u0320\7T\2\2\u031e\u031f\7\t\2\2\u031f\u0321\5\u013a")
        buf.write("\u009e\2\u0320\u031e\3\2\2\2\u0320\u0321\3\2\2\2\u0321")
        buf.write("\u008f\3\2\2\2\u0322\u0323\7W\2\2\u0323\u0324\5|?\2\u0324")
        buf.write("\u0325\7\u0086\2\2\u0325\u0328\5\u0120\u0091\2\u0326\u0327")
        buf.write("\7;\2\2\u0327\u0329\5\u0120\u0091\2\u0328\u0326\3\2\2")
        buf.write("\2\u0328\u0329\3\2\2\2\u0329\u032a\3\2\2\2\u032a\u032b")
        buf.write("\7B\2\2\u032b\u032c\7\n\2\2\u032c\u0091\3\2\2\2\u032d")
        buf.write("\u0330\5j\66\2\u032e\u032f\7,\2\2\u032f\u0331\5d\63\2")
        buf.write("\u0330\u032e\3\2\2\2\u0330\u0331\3\2\2\2\u0331\u0093\3")
        buf.write("\2\2\2\u0332\u0335\5\u0098M\2\u0333\u0334\7,\2\2\u0334")
        buf.write("\u0336\5\n\6\2\u0335\u0333\3\2\2\2\u0335\u0336\3\2\2\2")
        buf.write("\u0336\u0095\3\2\2\2\u0337\u0338\7\3\2\2\u0338\u033d\5")
        buf.write("\u0094K\2\u0339\u033a\7\5\2\2\u033a\u033c\5\u0094K\2\u033b")
        buf.write("\u0339\3\2\2\2\u033c\u033f\3\2\2\2\u033d\u033b\3\2\2\2")
        buf.write("\u033d\u033e\3\2\2\2\u033e\u0340\3\2\2\2\u033f\u033d\3")
        buf.write("\2\2\2\u0340\u0341\7\6\2\2\u0341\u0097\3\2\2\2\u0342\u0348")
        buf.write("\5D#\2\u0343\u0348\5j\66\2\u0344\u0348\5\u008aF\2\u0345")
        buf.write("\u0348\5\u00dan\2\u0346\u0348\5\u013c\u009f\2\u0347\u0342")
        buf.write("\3\2\2\2\u0347\u0343\3\2\2\2\u0347\u0344\3\2\2\2\u0347")
        buf.write("\u0345\3\2\2\2\u0347\u0346\3\2\2\2\u0348\u0099\3\2\2\2")
        buf.write("\u0349\u034a\5\u00c4c\2\u034a\u009b\3\2\2\2\u034b\u034c")
        buf.write("\5\u014c\u00a7\2\u034c\u034d\7\13\2\2\u034d\u034e\5\"")
        buf.write("\22\2\u034e\u034f\7\u0087\2\2\u034f\u0352\5$\23\2\u0350")
        buf.write("\u0351\7\64\2\2\u0351\u0353\5\u009aN\2\u0352\u0350\3\2")
        buf.write("\2\2\u0352\u0353\3\2\2\2\u0353\u009d\3\2\2\2\u0354\u0358")
        buf.write("\7\13\2\2\u0355\u0359\5|?\2\u0356\u0359\7\f\2\2\u0357")
        buf.write("\u0359\7\u008c\2\2\u0358\u0355\3\2\2\2\u0358\u0356\3\2")
        buf.write("\2\2\u0358\u0357\3\2\2\2\u0359\u009f\3\2\2\2\u035a\u035b")
        buf.write("\7[\2\2\u035b\u00a1\3\2\2\2\u035c\u035f\5\u00eav\2\u035d")
        buf.write("\u035f\5\u0148\u00a5\2\u035e\u035c\3\2\2\2\u035e\u035d")
        buf.write("\3\2\2\2\u035f\u00a3\3\2\2\2\u0360\u0361\7\32\2\2\u0361")
        buf.write("\u0362\5\u0110\u0089\2\u0362\u0363\t\4\2\2\u0363\u0364")
        buf.write("\5\u0110\u0089\2\u0364\u0365\t\4\2\2\u0365\u0366\5\u0110")
        buf.write("\u0089\2\u0366\u0367\7\33\2\2\u0367\u00a5\3\2\2\2\u0368")
        buf.write("\u036b\5\u00aaV\2\u0369\u036b\5\u00acW\2\u036a\u0368\3")
        buf.write("\2\2\2\u036a\u0369\3\2\2\2\u036b\u00a7\3\2\2\2\u036c\u0370")
        buf.write("\7Z\2\2\u036d\u036f\5\u00a6T\2\u036e\u036d\3\2\2\2\u036f")
        buf.write("\u0372\3\2\2\2\u0370\u036e\3\2\2\2\u0370\u0371\3\2\2\2")
        buf.write("\u0371\u00a9\3\2\2\2\u0372\u0370\3\2\2\2\u0373\u0374\5")
        buf.write("\26\f\2\u0374\u0375\7\t\2\2\u0375\u0376\5\u00aeX\2\u0376")
        buf.write("\u0377\7P\2\2\u0377\u0378\5\32\16\2\u0378\u0379\7\n\2")
        buf.write("\2\u0379\u00ab\3\2\2\2\u037a\u037b\5\32\16\2\u037b\u037c")
        buf.write("\7\n\2\2\u037c\u037d\5\u00aeX\2\u037d\u037e\7P\2\2\u037e")
        buf.write("\u037f\5\32\16\2\u037f\u0380\7\n\2\2\u0380\u00ad\3\2\2")
        buf.write("\2\u0381\u0383\t\5\2\2\u0382\u0384\5&\24\2\u0383\u0382")
        buf.write("\3\2\2\2\u0383\u0384\3\2\2\2\u0384\u0385\3\2\2\2\u0385")
        buf.write("\u0387\7k\2\2\u0386\u0381\3\2\2\2\u0386\u0387\3\2\2\2")
        buf.write("\u0387\u0388\3\2\2\2\u0388\u0389\5j\66\2\u0389\u00af\3")
        buf.write("\2\2\2\u038a\u038b\7\u0096\2\2\u038b\u00b1\3\2\2\2\u038c")
        buf.write("\u038e\7^\2\2\u038d\u038f\5&\24\2\u038e\u038d\3\2\2\2")
        buf.write("\u038e\u038f\3\2\2\2\u038f\u0390\3\2\2\2\u0390\u0392\7")
        buf.write("k\2\2\u0391\u0393\7\u008b\2\2\u0392\u0391\3\2\2\2\u0392")
        buf.write("\u0393\3\2\2\2\u0393\u0394\3\2\2\2\u0394\u0395\5\64\33")
        buf.write("\2\u0395\u00b3\3\2\2\2\u0396\u039e\7\u0099\2\2\u0397\u039e")
        buf.write("\7\u0098\2\2\u0398\u039e\7\u009a\2\2\u0399\u039e\7\u009b")
        buf.write("\2\2\u039a\u039e\7\u00a0\2\2\u039b\u039e\5\6\4\2\u039c")
        buf.write("\u039e\5h\65\2\u039d\u0396\3\2\2\2\u039d\u0397\3\2\2\2")
        buf.write("\u039d\u0398\3\2\2\2\u039d\u0399\3\2\2\2\u039d\u039a\3")
        buf.write("\2\2\2\u039d\u039b\3\2\2\2\u039d\u039c\3\2\2\2\u039e\u00b5")
        buf.write("\3\2\2\2\u039f\u03a3\7_\2\2\u03a0\u03a2\5\u00ba^\2\u03a1")
        buf.write("\u03a0\3\2\2\2\u03a2\u03a5\3\2\2\2\u03a3\u03a1\3\2\2\2")
        buf.write("\u03a3\u03a4\3\2\2\2\u03a4\u03a6\3\2\2\2\u03a5\u03a3\3")
        buf.write("\2\2\2\u03a6\u03a7\7C\2\2\u03a7\u03a8\7\n\2\2\u03a8\u00b7")
        buf.write("\3\2\2\2\u03a9\u03ab\5\u0144\u00a3\2\u03aa\u03a9\3\2\2")
        buf.write("\2\u03aa\u03ab\3\2\2\2\u03ab\u03ad\3\2\2\2\u03ac\u03ae")
        buf.write("\5Z.\2\u03ad\u03ac\3\2\2\2\u03ad\u03ae\3\2\2\2\u03ae\u00b9")
        buf.write("\3\2\2\2\u03af\u03b4\5\u014c\u00a7\2\u03b0\u03b1\7\5\2")
        buf.write("\2\u03b1\u03b3\5\u014c\u00a7\2\u03b2\u03b0\3\2\2\2\u03b3")
        buf.write("\u03b6\3\2\2\2\u03b4\u03b2\3\2\2\2\u03b4\u03b5\3\2\2\2")
        buf.write("\u03b5\u03b7\3\2\2\2\u03b6\u03b4\3\2\2\2\u03b7\u03ba\7")
        buf.write("\t\2\2\u03b8\u03bb\5\64\33\2\u03b9\u03bb\5@!\2\u03ba\u03b8")
        buf.write("\3\2\2\2\u03ba\u03b9\3\2\2\2\u03bb\u03bd\3\2\2\2\u03bc")
        buf.write("\u03be\5\u009eP\2\u03bd\u03bc\3\2\2\2\u03bd\u03be\3\2")
        buf.write("\2\2\u03be\u03bf\3\2\2\2\u03bf\u03c0\7\n\2\2\u03c0\u00bb")
        buf.write("\3\2\2\2\u03c1\u03c2\5|?\2\u03c2\u00bd\3\2\2\2\u03c3\u03c4")
        buf.write("\7`\2\2\u03c4\u00bf\3\2\2\2\u03c5\u03c8\5j\66\2\u03c6")
        buf.write("\u03c8\5\u013c\u009f\2\u03c7\u03c5\3\2\2\2\u03c7\u03c6")
        buf.write("\3\2\2\2\u03c8\u00c1\3\2\2\2\u03c9\u03ca\7\n\2\2\u03ca")
        buf.write("\u00c3\3\2\2\2\u03cb\u03cc\5\u0110\u0089\2\u03cc\u00c5")
        buf.write("\3\2\2\2\u03cd\u03ce\7h\2\2\u03ce\u00c7\3\2\2\2\u03cf")
        buf.write("\u03d0\7o\2\2\u03d0\u03d1\7\t\2\2\u03d1\u03d2\5\u011e")
        buf.write("\u0090\2\u03d2\u00c9\3\2\2\2\u03d3\u03d4\7\u0096\2\2\u03d4")
        buf.write("\u00cb\3\2\2\2\u03d5\u03d6\5|?\2\u03d6\u00cd\3\2\2\2\u03d7")
        buf.write("\u03d8\7\u0096\2\2\u03d8\u00cf\3\2\2\2\u03d9\u03da\5\u00c4")
        buf.write("c\2\u03da\u00d1\3\2\2\2\u03db\u03dc\5\u00dan\2\u03dc\u03dd")
        buf.write("\7\n\2\2\u03dd\u00d3\3\2\2\2\u03de\u03df\7\u0096\2\2\u03df")
        buf.write("\u00d5\3\2\2\2\u03e0\u03e1\5\u00d8m\2\u03e1\u03e2\5\u00dc")
        buf.write("o\2\u03e2\u03e3\5\u0120\u0091\2\u03e3\u03e4\7D\2\2\u03e4")
        buf.write("\u03e5\7\n\2\2\u03e5\u00d7\3\2\2\2\u03e6\u03e7\7q\2\2")
        buf.write("\u03e7\u03e9\5\u00d4k\2\u03e8\u03ea\5\u0150\u00a9\2\u03e9")
        buf.write("\u03e8\3\2\2\2\u03e9\u03ea\3\2\2\2\u03ea\u03eb\3\2\2\2")
        buf.write("\u03eb\u03ec\7\n\2\2\u03ec\u00d9\3\2\2\2\u03ed\u03f0\5")
        buf.write("\u00d4k\2\u03ee\u03f0\5\u011c\u008f\2\u03ef\u03ed\3\2")
        buf.write("\2\2\u03ef\u03ee\3\2\2\2\u03f0\u03f1\3\2\2\2\u03f1\u03f2")
        buf.write("\5\2\2\2\u03f2\u00db\3\2\2\2\u03f3\u03f5\5L\'\2\u03f4")
        buf.write("\u03f3\3\2\2\2\u03f5\u03f8\3\2\2\2\u03f6\u03f4\3\2\2\2")
        buf.write("\u03f6\u03f7\3\2\2\2\u03f7\u03fa\3\2\2\2\u03f8\u03f6\3")
        buf.write("\2\2\2\u03f9\u03fb\5B\"\2\u03fa\u03f9\3\2\2\2\u03fa\u03fb")
        buf.write("\3\2\2\2\u03fb\u03fd\3\2\2\2\u03fc\u03fe\5\u00b6\\\2\u03fd")
        buf.write("\u03fc\3\2\2\2\u03fd\u03fe\3\2\2\2\u03fe\u00dd\3\2\2\2")
        buf.write("\u03ff\u0402\5\b\5\2\u0400\u0402\5\u008eH\2\u0401\u03ff")
        buf.write("\3\2\2\2\u0401\u0400\3\2\2\2\u0402\u00df\3\2\2\2\u0403")
        buf.write("\u0404\7\20\2\2\u0404\u0407\5\32\16\2\u0405\u0407\5\u0126")
        buf.write("\u0094\2\u0406\u0403\3\2\2\2\u0406\u0405\3\2\2\2\u0407")
        buf.write("\u040a\3\2\2\2\u0408\u0406\3\2\2\2\u0408\u0409\3\2\2\2")
        buf.write("\u0409\u00e1\3\2\2\2\u040a\u0408\3\2\2\2\u040b\u040c\5")
        buf.write("\u014c\u00a7\2\u040c\u040d\7\34\2\2\u040d\u040e\5\4\3")
        buf.write("\2\u040e\u00e3\3\2\2\2\u040f\u0410\7r\2\2\u0410\u0411")
        buf.write("\7\3\2\2\u0411\u0412\5\u00e2r\2\u0412\u0413\7\35\2\2\u0413")
        buf.write("\u0414\5\u00e6t\2\u0414\u0415\7\6\2\2\u0415\u00e5\3\2")
        buf.write("\2\2\u0416\u0417\5\u00bc_\2\u0417\u00e7\3\2\2\2\u0418")
        buf.write("\u041d\7s\2\2\u0419\u041a\7\3\2\2\u041a\u041b\5\u00d0")
        buf.write("i\2\u041b\u041c\7\6\2\2\u041c\u041e\3\2\2\2\u041d\u0419")
        buf.write("\3\2\2\2\u041d\u041e\3\2\2\2\u041e\u00e9\3\2\2\2\u041f")
        buf.write("\u0420\7t\2\2\u0420\u0421\7R\2\2\u0421\u0423\5\u0106\u0084")
        buf.write("\2\u0422\u0424\5\u0096L\2\u0423\u0422\3\2\2\2\u0423\u0424")
        buf.write("\3\2\2\2\u0424\u0425\3\2\2\2\u0425\u0426\7\n\2\2\u0426")
        buf.write("\u00eb\3\2\2\2\u0427\u0428\5\32\16\2\u0428\u00ed\3\2\2")
        buf.write("\2\u0429\u042c\5^\60\2\u042a\u042c\5\u0130\u0099\2\u042b")
        buf.write("\u0429\3\2\2\2\u042b\u042a\3\2\2\2\u042c\u00ef\3\2\2\2")
        buf.write("\u042d\u042e\13\2\2\2\u042e\u00f1\3\2\2\2\u042f\u0431")
        buf.write("\5\u009cO\2\u0430\u042f\3\2\2\2\u0430\u0431\3\2\2\2\u0431")
        buf.write("\u0433\3\2\2\2\u0432\u0434\5\u0154\u00ab\2\u0433\u0432")
        buf.write("\3\2\2\2\u0433\u0434\3\2\2\2\u0434\u0436\3\2\2\2\u0435")
        buf.write("\u0437\5\u0146\u00a4\2\u0436\u0435\3\2\2\2\u0436\u0437")
        buf.write("\3\2\2\2\u0437\u00f3\3\2\2\2\u0438\u0439\7v\2\2\u0439")
        buf.write("\u043a\5\u00f2z\2\u043a\u043b\7\n\2\2\u043b\u043c\5\u0120")
        buf.write("\u0091\2\u043c\u043d\7F\2\2\u043d\u043e\7\n\2\2\u043e")
        buf.write("\u00f5\3\2\2\2\u043f\u0440\5\u00c4c\2\u0440\u00f7\3\2")
        buf.write("\2\2\u0441\u0446\7w\2\2\u0442\u0443\7\3\2\2\u0443\u0444")
        buf.write("\5|?\2\u0444\u0445\7\6\2\2\u0445\u0447\3\2\2\2\u0446\u0442")
        buf.write("\3\2\2\2\u0446\u0447\3\2\2\2\u0447\u0448\3\2\2\2\u0448")
        buf.write("\u0451\7\n\2\2\u0449\u044d\7w\2\2\u044a\u044b\7\3\2\2")
        buf.write("\u044b\u044c\7\u008c\2\2\u044c\u044e\7\6\2\2\u044d\u044a")
        buf.write("\3\2\2\2\u044d\u044e\3\2\2\2\u044e\u044f\3\2\2\2\u044f")
        buf.write("\u0451\7\n\2\2\u0450\u0441\3\2\2\2\u0450\u0449\3\2\2\2")
        buf.write("\u0451\u00f9\3\2\2\2\u0452\u0453\5\u00fe\u0080\2\u0453")
        buf.write("\u0455\5\u00dco\2\u0454\u0456\5\u0120\u0091\2\u0455\u0454")
        buf.write("\3\2\2\2\u0455\u0456\3\2\2\2\u0456\u0457\3\2\2\2\u0457")
        buf.write("\u0458\5Z.\2\u0458\u0459\7E\2\2\u0459\u045a\7\n\2\2\u045a")
        buf.write("\u00fb\3\2\2\2\u045b\u045c\7\u0096\2\2\u045c\u00fd\3\2")
        buf.write("\2\2\u045d\u045e\7y\2\2\u045e\u045f\5\u00fc\177\2\u045f")
        buf.write("\u0460\7P\2\2\u0460\u0461\5\u0100\u0081\2\u0461\u0462")
        buf.write("\7\n\2\2\u0462\u00ff\3\2\2\2\u0463\u0464\7\3\2\2\u0464")
        buf.write("\u0469\5j\66\2\u0465\u0466\7\5\2\2\u0466\u0468\5j\66\2")
        buf.write("\u0467\u0465\3\2\2\2\u0468\u046b\3\2\2\2\u0469\u0467\3")
        buf.write("\2\2\2\u0469\u046a\3\2\2\2\u046a\u046c\3\2\2\2\u046b\u0469")
        buf.write("\3\2\2\2\u046c\u046d\7\6\2\2\u046d\u0101\3\2\2\2\u046e")
        buf.write("\u0470\5\u00a2R\2\u046f\u046e\3\2\2\2\u0470\u0473\3\2")
        buf.write("\2\2\u0471\u046f\3\2\2\2\u0471\u0472\3\2\2\2\u0472\u0475")
        buf.write("\3\2\2\2\u0473\u0471\3\2\2\2\u0474\u0476\5B\"\2\u0475")
        buf.write("\u0474\3\2\2\2\u0475\u0476\3\2\2\2\u0476\u047b\3\2\2\2")
        buf.write("\u0477\u047a\5L\'\2\u0478\u047a\5\u00fa~\2\u0479\u0477")
        buf.write("\3\2\2\2\u0479\u0478\3\2\2\2\u047a\u047d\3\2\2\2\u047b")
        buf.write("\u0479\3\2\2\2\u047b\u047c\3\2\2\2\u047c\u0103\3\2\2\2")
        buf.write("\u047d\u047b\3\2\2\2\u047e\u047f\7z\2\2\u047f\u0480\7")
        buf.write("\u0095\2\2\u0480\u0481\7\n\2\2\u0481\u0482\5\u0102\u0082")
        buf.write("\2\u0482\u0483\7G\2\2\u0483\u0484\7\n\2\2\u0484\u0105")
        buf.write("\3\2\2\2\u0485\u0486\7\u0096\2\2\u0486\u0107\3\2\2\2\u0487")
        buf.write("\u0488\5|?\2\u0488\u0109\3\2\2\2\u0489\u048a\7{\2\2\u048a")
        buf.write("\u048b\7\3\2\2\u048b\u048c\5\u010c\u0087\2\u048c\u048d")
        buf.write("\7\6\2\2\u048d\u010b\3\2\2\2\u048e\u0493\5\u00c0a\2\u048f")
        buf.write("\u0490\7\5\2\2\u0490\u0492\5\u00c0a\2\u0491\u048f\3\2")
        buf.write("\2\2\u0492\u0495\3\2\2\2\u0493\u0491\3\2\2\2\u0493\u0494")
        buf.write("\3\2\2\2\u0494\u010d\3\2\2\2\u0495\u0493\3\2\2\2\u0496")
        buf.write("\u0497\7}\2\2\u0497\u0498\5&\24\2\u0498\u0499\7k\2\2\u0499")
        buf.write("\u049a\5\64\33\2\u049a\u010f\3\2\2\2\u049b\u04a0\5\u0132")
        buf.write("\u009a\2\u049c\u049d\t\6\2\2\u049d\u049f\5\u0132\u009a")
        buf.write("\2\u049e\u049c\3\2\2\2\u049f\u04a2\3\2\2\2\u04a0\u049e")
        buf.write("\3\2\2\2\u04a0\u04a1\3\2\2\2\u04a1\u0111\3\2\2\2\u04a2")
        buf.write("\u04a0\3\2\2\2\u04a3\u04b0\7\u0097\2\2\u04a4\u04b0\5\u00b4")
        buf.write("[\2\u04a5\u04b0\5\u0152\u00aa\2\u04a6\u04b0\5\u00a4S\2")
        buf.write("\u04a7\u04b0\5\u00e4s\2\u04a8\u04a9\7\3\2\2\u04a9\u04aa")
        buf.write("\5|?\2\u04aa\u04ab\7\6\2\2\u04ab\u04b0\3\2\2\2\u04ac\u04ad")
        buf.write("\5\u0140\u00a1\2\u04ad\u04ae\5\u0112\u008a\2\u04ae\u04b0")
        buf.write("\3\2\2\2\u04af\u04a3\3\2\2\2\u04af\u04a4\3\2\2\2\u04af")
        buf.write("\u04a5\3\2\2\2\u04af\u04a6\3\2\2\2\u04af\u04a7\3\2\2\2")
        buf.write("\u04af\u04a8\3\2\2\2\u04af\u04ac\3\2\2\2\u04b0\u0113\3")
        buf.write("\2\2\2\u04b1\u04b9\5\36\20\2\u04b2\u04b9\5 \21\2\u04b3")
        buf.write("\u04b9\5\u00a0Q\2\u04b4\u04b9\5\u00be`\2\u04b5\u04b9\5")
        buf.write("\u00c6d\2\u04b6\u04b9\5\u00e8u\2\u04b7\u04b9\5\u0122\u0092")
        buf.write("\2\u04b8\u04b1\3\2\2\2\u04b8\u04b2\3\2\2\2\u04b8\u04b3")
        buf.write("\3\2\2\2\u04b8\u04b4\3\2\2\2\u04b8\u04b5\3\2\2\2\u04b8")
        buf.write("\u04b6\3\2\2\2\u04b8\u04b7\3\2\2\2\u04b9\u0115\3\2\2\2")
        buf.write("\u04ba\u04bb\7\u0080\2\2\u04bb\u04bc\7\n\2\2\u04bc\u0117")
        buf.write("\3\2\2\2\u04bd\u04be\t\7\2\2\u04be\u0119\3\2\2\2\u04bf")
        buf.write("\u04c0\t\b\2\2\u04c0\u011b\3\2\2\2\u04c1\u04c2\t\t\2\2")
        buf.write("\u04c2\u011d\3\2\2\2\u04c3\u04cf\5\16\b\2\u04c4\u04cf")
        buf.write("\5\24\13\2\u04c5\u04cf\5.\30\2\u04c6\u04cf\5\66\34\2\u04c7")
        buf.write("\u04cf\5t;\2\u04c8\u04cf\5\u0090I\2\u04c9\u04cf\5\u00c2")
        buf.write("b\2\u04ca\u04cf\5\u00d2j\2\u04cb\u04cf\5\u00f4{\2\u04cc")
        buf.write("\u04cf\5\u00f8}\2\u04cd\u04cf\5\u0116\u008c\2\u04ce\u04c3")
        buf.write("\3\2\2\2\u04ce\u04c4\3\2\2\2\u04ce\u04c5\3\2\2\2\u04ce")
        buf.write("\u04c6\3\2\2\2\u04ce\u04c7\3\2\2\2\u04ce\u04c8\3\2\2\2")
        buf.write("\u04ce\u04c9\3\2\2\2\u04ce\u04ca\3\2\2\2\u04ce\u04cb\3")
        buf.write("\2\2\2\u04ce\u04cc\3\2\2\2\u04ce\u04cd\3\2\2\2\u04cf\u011f")
        buf.write("\3\2\2\2\u04d0\u04d4\5\u011e\u0090\2\u04d1\u04d3\5\u011e")
        buf.write("\u0090\2\u04d2\u04d1\3\2\2\2\u04d3\u04d6\3\2\2\2\u04d4")
        buf.write("\u04d2\3\2\2\2\u04d4\u04d5\3\2\2\2\u04d5\u0121\3\2\2\2")
        buf.write("\u04d6\u04d4\3\2\2\2\u04d7\u04de\7\u0082\2\2\u04d8\u04d9")
        buf.write("\7\3\2\2\u04d9\u04da\5\u0156\u00ac\2\u04da\u04dc\7\6\2")
        buf.write("\2\u04db\u04dd\7O\2\2\u04dc\u04db\3\2\2\2\u04dc\u04dd")
        buf.write("\3\2\2\2\u04dd\u04df\3\2\2\2\u04de\u04d8\3\2\2\2\u04de")
        buf.write("\u04df\3\2\2\2\u04df\u0123\3\2\2\2\u04e0\u04e2\5\u012a")
        buf.write("\u0096\2\u04e1\u04e0\3\2\2\2\u04e1\u04e2\3\2\2\2\u04e2")
        buf.write("\u04e4\3\2\2\2\u04e3\u04e5\5\u0128\u0095\2\u04e4\u04e3")
        buf.write("\3\2\2\2\u04e4\u04e5\3\2\2\2\u04e5\u0125\3\2\2\2\u04e6")
        buf.write("\u04e7\7\7\2\2\u04e7\u04e8\5\u00c4c\2\u04e8\u04e9\7\b")
        buf.write("\2\2\u04e9\u04f1\3\2\2\2\u04ea\u04eb\7\7\2\2\u04eb\u04ec")
        buf.write("\5\u00c4c\2\u04ec\u04ed\7\t\2\2\u04ed\u04ee\5\u00c4c\2")
        buf.write("\u04ee\u04ef\7\b\2\2\u04ef\u04f1\3\2\2\2\u04f0\u04e6\3")
        buf.write("\2\2\2\u04f0\u04ea\3\2\2\2\u04f1\u0127\3\2\2\2\u04f2\u04f3")
        buf.write("\7\u0083\2\2\u04f3\u04f4\7k\2\2\u04f4\u04f5\7\3\2\2\u04f5")
        buf.write("\u04fa\5j\66\2\u04f6\u04f7\7\5\2\2\u04f7\u04f9\5j\66\2")
        buf.write("\u04f8\u04f6\3\2\2\2\u04f9\u04fc\3\2\2\2\u04fa\u04f8\3")
        buf.write("\2\2\2\u04fa\u04fb\3\2\2\2\u04fb\u04fd\3\2\2\2\u04fc\u04fa")
        buf.write("\3\2\2\2\u04fd\u04fe\7\6\2\2\u04fe\u0129\3\2\2\2\u04ff")
        buf.write("\u0500\7%\2\2\u0500\u050b\7\u0084\2\2\u0501\u0503\7%\2")
        buf.write("\2\u0502\u0501\3\2\2\2\u0502\u0503\3\2\2\2\u0503\u0504")
        buf.write("\3\2\2\2\u0504\u0505\7\u0084\2\2\u0505\u0506\7k\2\2\u0506")
        buf.write("\u0507\7\3\2\2\u0507\u0508\5\u012c\u0097\2\u0508\u0509")
        buf.write("\7\6\2\2\u0509\u050b\3\2\2\2\u050a\u04ff\3\2\2\2\u050a")
        buf.write("\u0502\3\2\2\2\u050b\u012b\3\2\2\2\u050c\u0511\5\u012e")
        buf.write("\u0098\2\u050d\u050e\t\n\2\2\u050e\u0510\5\u012e\u0098")
        buf.write("\2\u050f\u050d\3\2\2\2\u0510\u0513\3\2\2\2\u0511\u050f")
        buf.write("\3\2\2\2\u0511\u0512\3\2\2\2\u0512\u012d\3\2\2\2\u0513")
        buf.write("\u0511\3\2\2\2\u0514\u051b\5j\66\2\u0515\u051b\5\60\31")
        buf.write("\2\u0516\u0517\7\3\2\2\u0517\u0518\5\u012c\u0097\2\u0518")
        buf.write("\u0519\7\6\2\2\u0519\u051b\3\2\2\2\u051a\u0514\3\2\2\2")
        buf.write("\u051a\u0515\3\2\2\2\u051a\u0516\3\2\2\2\u051b\u012f\3")
        buf.write("\2\2\2\u051c\u0520\7\4\2\2\u051d\u051f\5\u00f0y\2\u051e")
        buf.write("\u051d\3\2\2\2\u051f\u0522\3\2\2\2\u0520\u051e\3\2\2\2")
        buf.write("\u0520\u0521\3\2\2\2\u0521\u0131\3\2\2\2\u0522\u0520\3")
        buf.write("\2\2\2\u0523\u0528\5~@\2\u0524\u0525\t\13\2\2\u0525\u0527")
        buf.write("\5~@\2\u0526\u0524\3\2\2\2\u0527\u052a\3\2\2\2\u0528\u0526")
        buf.write("\3\2\2\2\u0528\u0529\3\2\2\2\u0529\u0530\3\2\2\2\u052a")
        buf.write("\u0528\3\2\2\2\u052b\u0530\7\u0088\2\2\u052c\u0530\7N")
        buf.write("\2\2\u052d\u0530\7\u0097\2\2\u052e\u0530\5\22\n\2\u052f")
        buf.write("\u0523\3\2\2\2\u052f\u052b\3\2\2\2\u052f\u052c\3\2\2\2")
        buf.write("\u052f\u052d\3\2\2\2\u052f\u052e\3\2\2\2\u0530\u0133\3")
        buf.write("\2\2\2\u0531\u0532\5\u0138\u009d\2\u0532\u0533\7\26\2")
        buf.write("\2\u0533\u0534\5\u013e\u00a0\2\u0534\u0536\7\n\2\2\u0535")
        buf.write("\u0537\5Z.\2\u0536\u0535\3\2\2\2\u0536\u0537\3\2\2\2\u0537")
        buf.write("\u0135\3\2\2\2\u0538\u0539\7\u0089\2\2\u0539\u053a\5\u0134")
        buf.write("\u009b\2\u053a\u053b\7H\2\2\u053b\u053c\7\n\2\2\u053c")
        buf.write("\u0137\3\2\2\2\u053d\u053e\7\u0096\2\2\u053e\u0139\3\2")
        buf.write("\2\2\u053f\u0540\7\u0096\2\2\u0540\u013b\3\2\2\2\u0541")
        buf.write("\u0542\7\u0096\2\2\u0542\u013d\3\2\2\2\u0543\u0549\5\62")
        buf.write("\32\2\u0544\u0549\5\u00c0a\2\u0545\u0549\5\u0114\u008b")
        buf.write("\2\u0546\u0549\5p9\2\u0547\u0549\5\u010a\u0086\2\u0548")
        buf.write("\u0543\3\2\2\2\u0548\u0544\3\2\2\2\u0548\u0545\3\2\2\2")
        buf.write("\u0548\u0546\3\2\2\2\u0548\u0547\3\2\2\2\u0549\u013f\3")
        buf.write("\2\2\2\u054a\u054b\t\f\2\2\u054b\u0141\3\2\2\2\u054c\u054d")
        buf.write("\5\u00b0Y\2\u054d\u054e\7\t\2\2\u054e\u0553\5\u00ecw\2")
        buf.write("\u054f\u0550\7\5\2\2\u0550\u0552\5\u00ecw\2\u0551\u054f")
        buf.write("\3\2\2\2\u0552\u0555\3\2\2\2\u0553\u0551\3\2\2\2\u0553")
        buf.write("\u0554\3\2\2\2\u0554\u0143\3\2\2\2\u0555\u0553\3\2\2\2")
        buf.write("\u0556\u0557\7\u008b\2\2\u0557\u0558\5\u0142\u00a2\2\u0558")
        buf.write("\u055e\7\n\2\2\u0559\u055a\5\u0142\u00a2\2\u055a\u055b")
        buf.write("\7\n\2\2\u055b\u055d\3\2\2\2\u055c\u0559\3\2\2\2\u055d")
        buf.write("\u0560\3\2\2\2\u055e\u055c\3\2\2\2\u055e\u055f\3\2\2\2")
        buf.write("\u055f\u0145\3\2\2\2\u0560\u055e\3\2\2\2\u0561\u0562\7")
        buf.write("\u008d\2\2\u0562\u0563\5\u00bc_\2\u0563\u0147\3\2\2\2")
        buf.write("\u0564\u0565\7\u008e\2\2\u0565\u0566\7R\2\2\u0566\u0568")
        buf.write("\5\u0106\u0084\2\u0567\u0569\5\u014a\u00a6\2\u0568\u0567")
        buf.write("\3\2\2\2\u0568\u0569\3\2\2\2\u0569\u056a\3\2\2\2\u056a")
        buf.write("\u056b\7\n\2\2\u056b\u0149\3\2\2\2\u056c\u056d\7\3\2\2")
        buf.write("\u056d\u0572\5\u0092J\2\u056e\u056f\7\5\2\2\u056f\u0571")
        buf.write("\5\u0092J\2\u0570\u056e\3\2\2\2\u0571\u0574\3\2\2\2\u0572")
        buf.write("\u0570\3\2\2\2\u0572\u0573\3\2\2\2\u0573\u0575\3\2\2\2")
        buf.write("\u0574\u0572\3\2\2\2\u0575\u0576\7\6\2\2\u0576\u014b\3")
        buf.write("\2\2\2\u0577\u0578\7\u0096\2\2\u0578\u014d\3\2\2\2\u0579")
        buf.write("\u057a\7\u0091\2\2\u057a\u057b\5\u0080A\2\u057b\u014f")
        buf.write("\3\2\2\2\u057c\u057d\7\3\2\2\u057d\u0582\5\u014e\u00a8")
        buf.write("\2\u057e\u057f\7\n\2\2\u057f\u0581\5\u014e\u00a8\2\u0580")
        buf.write("\u057e\3\2\2\2\u0581\u0584\3\2\2\2\u0582\u0580\3\2\2\2")
        buf.write("\u0582\u0583\3\2\2\2\u0583\u0585\3\2\2\2\u0584\u0582\3")
        buf.write("\2\2\2\u0585\u0586\7\6\2\2\u0586\u0151\3\2\2\2\u0587\u0588")
        buf.write("\5\u014c\u00a7\2\u0588\u0589\5\u00e0q\2\u0589\u059d\3")
        buf.write("\2\2\2\u058a\u058b\5\f\7\2\u058b\u058c\5\u00e0q\2\u058c")
        buf.write("\u059d\3\2\2\2\u058d\u058e\5\32\16\2\u058e\u058f\5\u00e0")
        buf.write("q\2\u058f\u059d\3\2\2\2\u0590\u0591\5J&\2\u0591\u0592")
        buf.write("\5\u00e0q\2\u0592\u059d\3\2\2\2\u0593\u059d\5j\66\2\u0594")
        buf.write("\u059d\5n8\2\u0595\u0596\5\u008aF\2\u0596\u0597\5\u00e0")
        buf.write("q\2\u0597\u059d\3\2\2\2\u0598\u0599\5\u00ceh\2\u0599\u059a")
        buf.write("\5\u00e0q\2\u059a\u059d\3\2\2\2\u059b\u059d\5\u00dan\2")
        buf.write("\u059c\u0587\3\2\2\2\u059c\u058a\3\2\2\2\u059c\u058d\3")
        buf.write("\2\2\2\u059c\u0590\3\2\2\2\u059c\u0593\3\2\2\2\u059c\u0594")
        buf.write("\3\2\2\2\u059c\u0595\3\2\2\2\u059c\u0598\3\2\2\2\u059c")
        buf.write("\u059b\3\2\2\2\u059d\u0153\3\2\2\2\u059e\u059f\7\u0093")
        buf.write("\2\2\u059f\u05a0\5\u00bc_\2\u05a0\u0155\3\2\2\2\u05a1")
        buf.write("\u05a2\5\u00c4c\2\u05a2\u0157\3\2\2\2|\u015b\u0161\u0166")
        buf.write("\u0173\u017b\u0192\u0198\u019b\u01a4\u01ad\u01b3\u01b9")
        buf.write("\u01c0\u01ca\u01cc\u01df\u01e8\u01ec\u01fe\u0207\u020d")
        buf.write("\u0217\u021a\u0225\u0231\u0237\u0249\u024f\u0255\u025f")
        buf.write("\u0275\u027f\u0284\u0286\u02a1\u02a4\u02af\u02be\u02c9")
        buf.write("\u02ce\u02d5\u02da\u02e2\u02e7\u02ee\u02fa\u0306\u030f")
        buf.write("\u0313\u0320\u0328\u0330\u0335\u033d\u0347\u0352\u0358")
        buf.write("\u035e\u036a\u0370\u0383\u0386\u038e\u0392\u039d\u03a3")
        buf.write("\u03aa\u03ad\u03b4\u03ba\u03bd\u03c7\u03e9\u03ef\u03f6")
        buf.write("\u03fa\u03fd\u0401\u0406\u0408\u041d\u0423\u042b\u0430")
        buf.write("\u0433\u0436\u0446\u044d\u0450\u0455\u0469\u0471\u0475")
        buf.write("\u0479\u047b\u0493\u04a0\u04af\u04b8\u04ce\u04d4\u04dc")
        buf.write("\u04de\u04e1\u04e4\u04f0\u04fa\u0502\u050a\u0511\u051a")
        buf.write("\u0520\u0528\u052f\u0536\u0548\u0553\u055e\u0568\u0572")
        buf.write("\u0582\u059c")
        return buf.getvalue()


class expressParser ( Parser ):

    grammarFileName = "express.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "'--'", "','", "')'", "'['", "']'", 
                     "':'", "';'", "':='", "'[]'", "'\\'", "'(*'", "'*)'", 
                     "'.'", "'<'", "'>'", "'<='", "'>='", "'<>'", "'='", 
                     "':<>:'", "':=:'", "'**'", "'{'", "'}'", "'<*'", "'|'", 
                     "'+'", "'-'", "'?'", "'*'", "'/'", "'||'", "'ABS'", 
                     "'ABSTRACT'", "'ACOS'", "'AGGREGATE'", "'ALIAS'", "'AND'", 
                     "'ANDOR'", "'ARRAY'", "'AS'", "'ASIN'", "'ATAN'", "'BAG'", 
                     "'BEGIN'", "'BINARY'", "'BLENGTH'", "'BOOLEAN'", "'BY'", 
                     "'CASE'", "'CONSTANT'", "'CONST_E'", "'COS'", "'DERIVE'", 
                     "'DIV'", "'ELSE'", "'END'", "'END_ALIAS'", "'END_CASE'", 
                     "'END_CONSTANT'", "'END_ENTITY'", "'END_FUNCTION'", 
                     "'END_IF'", "'END_LOCAL'", "'END_PROCEDURE'", "'END_RULE'", 
                     "'END_REPEAT'", "'END_SCHEMA'", "'END_TYPE'", "'ENTITY'", 
                     "'ENUMERATION'", "'ESCAPE'", "'EXISTS'", "'EXP'", "'FALSE'", 
                     "'FIXED'", "'FOR'", "'FORMAT'", "'FROM'", "'FUNCTION'", 
                     "<INVALID>", "'HIBOUND'", "'HIINDEX'", "'IF'", "'IN'", 
                     "'INSERT'", "'INVERSE'", "'INTEGER'", "'LENGTH'", "'LIKE'", 
                     "'LIST'", "'LOCAL'", "'LOGICAL'", "'LOBOUND'", "'LOINDEX'", 
                     "'LOG'", "'LOG2'", "'LOG10'", "'MOD'", "'NOT'", "'NUMBER'", 
                     "'NVL'", "'ODD'", "<INVALID>", "'ONEOF'", "'OPTIONAL'", 
                     "'OR'", "'OTHERWISE'", "'PI'", "'PROCEDURE'", "'QUERY'", 
                     "'REAL'", "'REFERENCE'", "'REMOVE'", "'REPEAT'", "'RETURN'", 
                     "'ROLESOF'", "'RULE'", "'SCHEMA'", "'SELECT'", "'SELF'", 
                     "'SET'", "'SIN'", "'SIZEOF'", "'SKIP'", "'SQRT'", "'STRING'", 
                     "'SUBTYPE'", "'SUPERTYPE'", "'TAN'", "'THEN'", "'TO'", 
                     "'TRUE'", "'TYPE'", "'TYPEOF'", "'UNIQUE'", "'UNKNOWN'", 
                     "'UNTIL'", "'USE'", "'USEDIN'", "'VALUE'", "'VAR'", 
                     "'WHERE'", "'WHILE'", "'XOR'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'''" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ABS", "ABSTRACT", "ACOS", 
                      "AGGREGATE", "ALIAS", "AND", "ANDOR", "ARRAY", "AS", 
                      "ASIN", "ATAN", "BAG", "BEGIN", "BINARY", "BLENGTH", 
                      "BOOLEAN", "BY", "CASE", "CONSTANT", "CONST_E", "COS", 
                      "DERIVE", "DIV", "ELSE", "END", "END_ALIAS", "END_CASE", 
                      "END_CONSTANT", "END_ENTITY", "END_FUNCTION", "END_IF", 
                      "END_LOCAL", "END_PROCEDURE", "END_RULE", "END_REPEAT", 
                      "END_SCHEMA", "END_TYPE", "ENTITY", "ENUMERATION", 
                      "ESCAPE", "EXISTS", "EXP", "FALSE", "FIXED", "FOR", 
                      "FORMAT", "FROM", "FUNCTION", "GENERIC", "HIBOUND", 
                      "HIINDEX", "IF", "IN", "INSERT", "INVERSE", "INTEGER", 
                      "LENGTH", "LIKE", "LIST", "LOCAL", "LOGICAL", "LOBOUND", 
                      "LOINDEX", "LOG", "LOG2", "LOG10", "MOD", "NOT", "NUMBER", 
                      "NVL", "ODD", "OF", "ONEOF", "OPTIONAL", "OR", "OTHERWISE", 
                      "PI", "PROCEDURE", "QUERY", "REAL", "REFERENCE", "REMOVE", 
                      "REPEAT", "RETURN", "ROLESOF", "RULE", "SCHEMA", "SELECT", 
                      "SELF", "SET", "SIN", "SIZEOF", "SKIP2", "SQRT", "STRING", 
                      "SUBTYPE", "SUPERTYPE", "TAN", "THEN", "TO", "TRUE", 
                      "TYPE", "TYPEOF", "UNIQUE", "UNKNOWN", "UNTIL", "USE", 
                      "USEDIN", "VALUE", "VAR", "WHERE", "WHILE", "XOR", 
                      "SchemaDef", "SimpleId", "Path", "IntegerLiteral", 
                      "BinaryLiteral", "LogicalLiteral", "RealLiteral", 
                      "Digits", "Letter", "Character", "QuoteChar", "StringLiteral", 
                      "NewlineChar", "WS", "Comments" ]

    RULE_actualParams = 0
    RULE_aggregateExpr = 1
    RULE_aggregateLiteral = 2
    RULE_aggregateType = 3
    RULE_aliasDef = 4
    RULE_aliasRef = 5
    RULE_aliasStmt = 6
    RULE_allTypeSel = 7
    RULE_arrayType = 8
    RULE_assignmentStmt = 9
    RULE_attrDef = 10
    RULE_attributes = 11
    RULE_attrRef = 12
    RULE_bagType = 13
    RULE_binaryType = 14
    RULE_booleanType = 15
    RULE_bound1 = 16
    RULE_bound2 = 17
    RULE_boundSpec = 18
    RULE_caseAction = 19
    RULE_caseBody = 20
    RULE_caseLabel = 21
    RULE_caseStmt = 22
    RULE_choice = 23
    RULE_collectionType = 24
    RULE_collectionTypeSel = 25
    RULE_compoundStmt = 26
    RULE_conformantArray = 27
    RULE_conformantBag = 28
    RULE_conformantList = 29
    RULE_conformantSet = 30
    RULE_conformantType = 31
    RULE_constantDecl = 32
    RULE_constantRef = 33
    RULE_constBody = 34
    RULE_constDef = 35
    RULE_constRef = 36
    RULE_declaration = 37
    RULE_deriveClause = 38
    RULE_deriveDef = 39
    RULE_derivedAttr = 40
    RULE_derivedRedef = 41
    RULE_derivedPath = 42
    RULE_domainRule = 43
    RULE_domainRules = 44
    RULE_element = 45
    RULE_embeddedRemark = 46
    RULE_entityBody = 47
    RULE_entityDecl = 48
    RULE_entityDef = 49
    RULE_entityHead = 50
    RULE_entityLiteral = 51
    RULE_entityRef = 52
    RULE_enumDef = 53
    RULE_enumRef = 54
    RULE_enumType = 55
    RULE_enumValues = 56
    RULE_escapeStmt = 57
    RULE_explDef = 58
    RULE_explicitClause = 59
    RULE_explRedef = 60
    RULE_expression = 61
    RULE_factor = 62
    RULE_formalParam = 63
    RULE_formalParams = 64
    RULE_funcDef = 65
    RULE_funcHead = 66
    RULE_returnTypeChoice = 67
    RULE_funcRef = 68
    RULE_functionDecl = 69
    RULE_genericType = 70
    RULE_ifStmt = 71
    RULE_importEntity = 72
    RULE_importItem = 73
    RULE_importList = 74
    RULE_importRef = 75
    RULE_incr = 76
    RULE_incrementControl = 77
    RULE_init = 78
    RULE_integerType = 79
    RULE_interfaceSpecification = 80
    RULE_interval = 81
    RULE_inverseAttr = 82
    RULE_inverseClause = 83
    RULE_inverseDef = 84
    RULE_inverseRedef = 85
    RULE_inverseType = 86
    RULE_labelDef = 87
    RULE_listType = 88
    RULE_literal = 89
    RULE_localDecl = 90
    RULE_localRules = 91
    RULE_localVar = 92
    RULE_logicalExpr = 93
    RULE_logicalType = 94
    RULE_namedType = 95
    RULE_nullStmt = 96
    RULE_numberExpr = 97
    RULE_numberType = 98
    RULE_otherAction = 99
    RULE_paramDef = 100
    RULE_parameter = 101
    RULE_paramRef = 102
    RULE_precisionSpec = 103
    RULE_procCallStmt = 104
    RULE_procDef = 105
    RULE_procedureDecl = 106
    RULE_procHead = 107
    RULE_procRef = 108
    RULE_prolog = 109
    RULE_pseudoType = 110
    RULE_qualifier = 111
    RULE_queryAssignment = 112
    RULE_queryExpr = 113
    RULE_queryScan = 114
    RULE_realType = 115
    RULE_referenceClause = 116
    RULE_referencedAttr = 117
    RULE_remark = 118
    RULE_remarkStuff = 119
    RULE_repeatControl = 120
    RULE_repeateStmt = 121
    RULE_repetition = 122
    RULE_returnStmt = 123
    RULE_ruleDecl = 124
    RULE_ruleDef = 125
    RULE_ruleHead = 126
    RULE_ruleList = 127
    RULE_schemaBody = 128
    RULE_schemaDecl = 129
    RULE_schemaRef = 130
    RULE_selector = 131
    RULE_selectType = 132
    RULE_selectValues = 133
    RULE_setType = 134
    RULE_simpleExpr = 135
    RULE_simpleFactor = 136
    RULE_simpleType = 137
    RULE_skipStmt = 138
    RULE_stdConst = 139
    RULE_stdFunc = 140
    RULE_stdProc = 141
    RULE_stmt = 142
    RULE_stmts = 143
    RULE_stringType = 144
    RULE_subSuper = 145
    RULE_subscript = 146
    RULE_subtypeDecl = 147
    RULE_supertypeDecl = 148
    RULE_supertypeExpr = 149
    RULE_supertypeFactor = 150
    RULE_tailRemark = 151
    RULE_term = 152
    RULE_typeBody = 153
    RULE_typeDecl = 154
    RULE_typeDef = 155
    RULE_typeLabel = 156
    RULE_typeRef = 157
    RULE_typeSel = 158
    RULE_unaryOp = 159
    RULE_uniqueRule = 160
    RULE_uniqueRules = 161
    RULE_untilControl = 162
    RULE_useClause = 163
    RULE_useList = 164
    RULE_varDef = 165
    RULE_varParam = 166
    RULE_varParams = 167
    RULE_varRef = 168
    RULE_whileControl = 169
    RULE_width = 170

    ruleNames =  [ "actualParams", "aggregateExpr", "aggregateLiteral", 
                   "aggregateType", "aliasDef", "aliasRef", "aliasStmt", 
                   "allTypeSel", "arrayType", "assignmentStmt", "attrDef", 
                   "attributes", "attrRef", "bagType", "binaryType", "booleanType", 
                   "bound1", "bound2", "boundSpec", "caseAction", "caseBody", 
                   "caseLabel", "caseStmt", "choice", "collectionType", 
                   "collectionTypeSel", "compoundStmt", "conformantArray", 
                   "conformantBag", "conformantList", "conformantSet", "conformantType", 
                   "constantDecl", "constantRef", "constBody", "constDef", 
                   "constRef", "declaration", "deriveClause", "deriveDef", 
                   "derivedAttr", "derivedRedef", "derivedPath", "domainRule", 
                   "domainRules", "element", "embeddedRemark", "entityBody", 
                   "entityDecl", "entityDef", "entityHead", "entityLiteral", 
                   "entityRef", "enumDef", "enumRef", "enumType", "enumValues", 
                   "escapeStmt", "explDef", "explicitClause", "explRedef", 
                   "expression", "factor", "formalParam", "formalParams", 
                   "funcDef", "funcHead", "returnTypeChoice", "funcRef", 
                   "functionDecl", "genericType", "ifStmt", "importEntity", 
                   "importItem", "importList", "importRef", "incr", "incrementControl", 
                   "init", "integerType", "interfaceSpecification", "interval", 
                   "inverseAttr", "inverseClause", "inverseDef", "inverseRedef", 
                   "inverseType", "labelDef", "listType", "literal", "localDecl", 
                   "localRules", "localVar", "logicalExpr", "logicalType", 
                   "namedType", "nullStmt", "numberExpr", "numberType", 
                   "otherAction", "paramDef", "parameter", "paramRef", "precisionSpec", 
                   "procCallStmt", "procDef", "procedureDecl", "procHead", 
                   "procRef", "prolog", "pseudoType", "qualifier", "queryAssignment", 
                   "queryExpr", "queryScan", "realType", "referenceClause", 
                   "referencedAttr", "remark", "remarkStuff", "repeatControl", 
                   "repeateStmt", "repetition", "returnStmt", "ruleDecl", 
                   "ruleDef", "ruleHead", "ruleList", "schemaBody", "schemaDecl", 
                   "schemaRef", "selector", "selectType", "selectValues", 
                   "setType", "simpleExpr", "simpleFactor", "simpleType", 
                   "skipStmt", "stdConst", "stdFunc", "stdProc", "stmt", 
                   "stmts", "stringType", "subSuper", "subscript", "subtypeDecl", 
                   "supertypeDecl", "supertypeExpr", "supertypeFactor", 
                   "tailRemark", "term", "typeBody", "typeDecl", "typeDef", 
                   "typeLabel", "typeRef", "typeSel", "unaryOp", "uniqueRule", 
                   "uniqueRules", "untilControl", "useClause", "useList", 
                   "varDef", "varParam", "varParams", "varRef", "whileControl", 
                   "width" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    ABS=34
    ABSTRACT=35
    ACOS=36
    AGGREGATE=37
    ALIAS=38
    AND=39
    ANDOR=40
    ARRAY=41
    AS=42
    ASIN=43
    ATAN=44
    BAG=45
    BEGIN=46
    BINARY=47
    BLENGTH=48
    BOOLEAN=49
    BY=50
    CASE=51
    CONSTANT=52
    CONST_E=53
    COS=54
    DERIVE=55
    DIV=56
    ELSE=57
    END=58
    END_ALIAS=59
    END_CASE=60
    END_CONSTANT=61
    END_ENTITY=62
    END_FUNCTION=63
    END_IF=64
    END_LOCAL=65
    END_PROCEDURE=66
    END_RULE=67
    END_REPEAT=68
    END_SCHEMA=69
    END_TYPE=70
    ENTITY=71
    ENUMERATION=72
    ESCAPE=73
    EXISTS=74
    EXP=75
    FALSE=76
    FIXED=77
    FOR=78
    FORMAT=79
    FROM=80
    FUNCTION=81
    GENERIC=82
    HIBOUND=83
    HIINDEX=84
    IF=85
    IN=86
    INSERT=87
    INVERSE=88
    INTEGER=89
    LENGTH=90
    LIKE=91
    LIST=92
    LOCAL=93
    LOGICAL=94
    LOBOUND=95
    LOINDEX=96
    LOG=97
    LOG2=98
    LOG10=99
    MOD=100
    NOT=101
    NUMBER=102
    NVL=103
    ODD=104
    OF=105
    ONEOF=106
    OPTIONAL=107
    OR=108
    OTHERWISE=109
    PI=110
    PROCEDURE=111
    QUERY=112
    REAL=113
    REFERENCE=114
    REMOVE=115
    REPEAT=116
    RETURN=117
    ROLESOF=118
    RULE=119
    SCHEMA=120
    SELECT=121
    SELF=122
    SET=123
    SIN=124
    SIZEOF=125
    SKIP2=126
    SQRT=127
    STRING=128
    SUBTYPE=129
    SUPERTYPE=130
    TAN=131
    THEN=132
    TO=133
    TRUE=134
    TYPE=135
    TYPEOF=136
    UNIQUE=137
    UNKNOWN=138
    UNTIL=139
    USE=140
    USEDIN=141
    VALUE=142
    VAR=143
    WHERE=144
    WHILE=145
    XOR=146
    SchemaDef=147
    SimpleId=148
    Path=149
    IntegerLiteral=150
    BinaryLiteral=151
    LogicalLiteral=152
    RealLiteral=153
    Digits=154
    Letter=155
    Character=156
    QuoteChar=157
    StringLiteral=158
    NewlineChar=159
    WS=160
    Comments=161

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ActualParamsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ParameterContext)
            else:
                return self.getTypedRuleContext(expressParser.ParameterContext,i)


        def SimpleId(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.SimpleId)
            else:
                return self.getToken(expressParser.SimpleId, i)

        def getRuleIndex(self):
            return expressParser.RULE_actualParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActualParams" ):
                listener.enterActualParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActualParams" ):
                listener.exitActualParams(self)




    def actualParams(self):

        localctx = expressParser.ActualParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_actualParams)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(expressParser.T__0)
            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__1:
                self.state = 343
                self.match(expressParser.T__1)
                self.state = 344
                self.match(expressParser.SimpleId)


            self.state = 347
            self.parameter()
            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 348
                self.match(expressParser.T__2)
                self.state = 351
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.T__1:
                    self.state = 349
                    self.match(expressParser.T__1)
                    self.state = 350
                    self.match(expressParser.SimpleId)


                self.state = 353
                self.parameter()
                self.state = 358
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 359
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_aggregateExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateExpr" ):
                listener.enterAggregateExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateExpr" ):
                listener.exitAggregateExpr(self)




    def aggregateExpr(self):

        localctx = expressParser.AggregateExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_aggregateExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ElementContext)
            else:
                return self.getTypedRuleContext(expressParser.ElementContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_aggregateLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateLiteral" ):
                listener.enterAggregateLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateLiteral" ):
                listener.exitAggregateLiteral(self)




    def aggregateLiteral(self):

        localctx = expressParser.AggregateLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_aggregateLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(expressParser.T__4)
            self.state = 364
            self.element()
            self.state = 369
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 365
                self.match(expressParser.T__2)
                self.state = 366
                self.element()
                self.state = 371
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 372
            self.match(expressParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AGGREGATE(self):
            return self.getToken(expressParser.AGGREGATE, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def allTypeSel(self):
            return self.getTypedRuleContext(expressParser.AllTypeSelContext,0)


        def typeLabel(self):
            return self.getTypedRuleContext(expressParser.TypeLabelContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_aggregateType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateType" ):
                listener.enterAggregateType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateType" ):
                listener.exitAggregateType(self)




    def aggregateType(self):

        localctx = expressParser.AggregateTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_aggregateType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            self.match(expressParser.AGGREGATE)
            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__6:
                self.state = 375
                self.match(expressParser.T__6)
                self.state = 376
                self.typeLabel()


            self.state = 379
            self.match(expressParser.OF)
            self.state = 380
            self.allTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_aliasDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasDef" ):
                listener.enterAliasDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasDef" ):
                listener.exitAliasDef(self)




    def aliasDef(self):

        localctx = expressParser.AliasDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_aliasDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_aliasRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasRef" ):
                listener.enterAliasRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasRef" ):
                listener.exitAliasRef(self)




    def aliasRef(self):

        localctx = expressParser.AliasRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_aliasRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 384
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALIAS(self):
            return self.getToken(expressParser.ALIAS, 0)

        def aliasDef(self):
            return self.getTypedRuleContext(expressParser.AliasDefContext,0)


        def FOR(self):
            return self.getToken(expressParser.FOR, 0)

        def varRef(self):
            return self.getTypedRuleContext(expressParser.VarRefContext,0)


        def stmts(self):
            return self.getTypedRuleContext(expressParser.StmtsContext,0)


        def END_ALIAS(self):
            return self.getToken(expressParser.END_ALIAS, 0)

        def getRuleIndex(self):
            return expressParser.RULE_aliasStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasStmt" ):
                listener.enterAliasStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasStmt" ):
                listener.exitAliasStmt(self)




    def aliasStmt(self):

        localctx = expressParser.AliasStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_aliasStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 386
            self.match(expressParser.ALIAS)
            self.state = 387
            self.aliasDef()
            self.state = 388
            self.match(expressParser.FOR)
            self.state = 389
            self.varRef()
            self.state = 390
            self.match(expressParser.T__7)
            self.state = 391
            self.stmts()
            self.state = 392
            self.match(expressParser.END_ALIAS)
            self.state = 393
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllTypeSelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregateType(self):
            return self.getTypedRuleContext(expressParser.AggregateTypeContext,0)


        def conformantType(self):
            return self.getTypedRuleContext(expressParser.ConformantTypeContext,0)


        def simpleType(self):
            return self.getTypedRuleContext(expressParser.SimpleTypeContext,0)


        def namedType(self):
            return self.getTypedRuleContext(expressParser.NamedTypeContext,0)


        def pseudoType(self):
            return self.getTypedRuleContext(expressParser.PseudoTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_allTypeSel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllTypeSel" ):
                listener.enterAllTypeSel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllTypeSel" ):
                listener.exitAllTypeSel(self)




    def allTypeSel(self):

        localctx = expressParser.AllTypeSelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_allTypeSel)
        try:
            self.state = 400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 395
                self.aggregateType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 396
                self.conformantType()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 397
                self.simpleType()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 398
                self.namedType()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 399
                self.pseudoType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(expressParser.ARRAY, 0)

        def boundSpec(self):
            return self.getTypedRuleContext(expressParser.BoundSpecContext,0)


        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def OPTIONAL(self):
            return self.getToken(expressParser.OPTIONAL, 0)

        def UNIQUE(self):
            return self.getToken(expressParser.UNIQUE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_arrayType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayType" ):
                listener.enterArrayType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayType" ):
                listener.exitArrayType(self)




    def arrayType(self):

        localctx = expressParser.ArrayTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_arrayType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.match(expressParser.ARRAY)
            self.state = 403
            self.boundSpec()
            self.state = 404
            self.match(expressParser.OF)
            self.state = 406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.OPTIONAL:
                self.state = 405
                self.match(expressParser.OPTIONAL)


            self.state = 409
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.UNIQUE:
                self.state = 408
                self.match(expressParser.UNIQUE)


            self.state = 411
            self.collectionTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varRef(self):
            return self.getTypedRuleContext(expressParser.VarRefContext,0)


        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def derivedPath(self):
            return self.getTypedRuleContext(expressParser.DerivedPathContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_assignmentStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentStmt" ):
                listener.enterAssignmentStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentStmt" ):
                listener.exitAssignmentStmt(self)




    def assignmentStmt(self):

        localctx = expressParser.AssignmentStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_assignmentStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.varRef()
            self.state = 414
            self.match(expressParser.T__8)
            self.state = 418
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 415
                self.expression()
                pass

            elif la_ == 2:
                self.state = 416
                self.derivedPath()
                pass

            elif la_ == 3:
                self.state = 417
                self.match(expressParser.T__9)
                pass


            self.state = 420
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttrDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def Path(self):
            return self.getToken(expressParser.Path, 0)

        def getRuleIndex(self):
            return expressParser.RULE_attrDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrDef" ):
                listener.enterAttrDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrDef" ):
                listener.exitAttrDef(self)




    def attrDef(self):

        localctx = expressParser.AttrDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_attrDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            _la = self._input.LA(1)
            if not(_la==expressParser.SimpleId or _la==expressParser.Path):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def explicitClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ExplicitClauseContext)
            else:
                return self.getTypedRuleContext(expressParser.ExplicitClauseContext,i)


        def deriveClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.DeriveClauseContext)
            else:
                return self.getTypedRuleContext(expressParser.DeriveClauseContext,i)


        def inverseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.InverseClauseContext)
            else:
                return self.getTypedRuleContext(expressParser.InverseClauseContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_attributes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributes" ):
                listener.enterAttributes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributes" ):
                listener.exitAttributes(self)




    def attributes(self):

        localctx = expressParser.AttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_attributes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 427
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.SimpleId or _la==expressParser.Path:
                self.state = 424
                self.explicitClause()
                self.state = 429
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 433
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.DERIVE:
                self.state = 430
                self.deriveClause()
                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 439
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.INVERSE:
                self.state = 436
                self.inverseClause()
                self.state = 441
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttrRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def Path(self):
            return self.getToken(expressParser.Path, 0)

        def getRuleIndex(self):
            return expressParser.RULE_attrRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRef" ):
                listener.enterAttrRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRef" ):
                listener.exitAttrRef(self)




    def attrRef(self):

        localctx = expressParser.AttrRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_attrRef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            _la = self._input.LA(1)
            if not(_la==expressParser.SimpleId or _la==expressParser.Path):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BagTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BAG(self):
            return self.getToken(expressParser.BAG, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def boundSpec(self):
            return self.getTypedRuleContext(expressParser.BoundSpecContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_bagType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBagType" ):
                listener.enterBagType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBagType" ):
                listener.exitBagType(self)




    def bagType(self):

        localctx = expressParser.BagTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_bagType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.match(expressParser.BAG)
            self.state = 446
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__4:
                self.state = 445
                self.boundSpec()


            self.state = 448
            self.match(expressParser.OF)
            self.state = 449
            self.collectionTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BINARY(self):
            return self.getToken(expressParser.BINARY, 0)

        def width(self):
            return self.getTypedRuleContext(expressParser.WidthContext,0)


        def FIXED(self):
            return self.getToken(expressParser.FIXED, 0)

        def getRuleIndex(self):
            return expressParser.RULE_binaryType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryType" ):
                listener.enterBinaryType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryType" ):
                listener.exitBinaryType(self)




    def binaryType(self):

        localctx = expressParser.BinaryTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_binaryType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(expressParser.BINARY)
            self.state = 458
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__0:
                self.state = 452
                self.match(expressParser.T__0)
                self.state = 453
                self.width()
                self.state = 454
                self.match(expressParser.T__3)
                self.state = 456
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.FIXED:
                    self.state = 455
                    self.match(expressParser.FIXED)




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(expressParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return expressParser.RULE_booleanType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanType" ):
                listener.enterBooleanType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanType" ):
                listener.exitBooleanType(self)




    def booleanType(self):

        localctx = expressParser.BooleanTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_booleanType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 460
            self.match(expressParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bound1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self):
            return self.getTypedRuleContext(expressParser.NumberExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_bound1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBound1" ):
                listener.enterBound1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBound1" ):
                listener.exitBound1(self)




    def bound1(self):

        localctx = expressParser.Bound1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_bound1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.numberExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bound2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self):
            return self.getTypedRuleContext(expressParser.NumberExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_bound2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBound2" ):
                listener.enterBound2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBound2" ):
                listener.exitBound2(self)




    def bound2(self):

        localctx = expressParser.Bound2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_bound2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 464
            self.numberExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoundSpecContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bound1(self):
            return self.getTypedRuleContext(expressParser.Bound1Context,0)


        def bound2(self):
            return self.getTypedRuleContext(expressParser.Bound2Context,0)


        def getRuleIndex(self):
            return expressParser.RULE_boundSpec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoundSpec" ):
                listener.enterBoundSpec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoundSpec" ):
                listener.exitBoundSpec(self)




    def boundSpec(self):

        localctx = expressParser.BoundSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_boundSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 466
            self.match(expressParser.T__4)
            self.state = 467
            self.bound1()
            self.state = 468
            self.match(expressParser.T__6)
            self.state = 469
            self.bound2()
            self.state = 470
            self.match(expressParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseLabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.CaseLabelContext)
            else:
                return self.getTypedRuleContext(expressParser.CaseLabelContext,i)


        def stmt(self):
            return self.getTypedRuleContext(expressParser.StmtContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_caseAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseAction" ):
                listener.enterCaseAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseAction" ):
                listener.exitCaseAction(self)




    def caseAction(self):

        localctx = expressParser.CaseActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_caseAction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.caseLabel()
            self.state = 477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 473
                self.match(expressParser.T__2)
                self.state = 474
                self.caseLabel()
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 480
            self.match(expressParser.T__6)
            self.state = 481
            self.stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseAction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.CaseActionContext)
            else:
                return self.getTypedRuleContext(expressParser.CaseActionContext,i)


        def otherAction(self):
            return self.getTypedRuleContext(expressParser.OtherActionContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_caseBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseBody" ):
                listener.enterCaseBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseBody" ):
                listener.exitCaseBody(self)




    def caseBody(self):

        localctx = expressParser.CaseBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_caseBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__0) | (1 << expressParser.T__4) | (1 << expressParser.T__23) | (1 << expressParser.T__27) | (1 << expressParser.T__28) | (1 << expressParser.T__29) | (1 << expressParser.ABS) | (1 << expressParser.ACOS) | (1 << expressParser.ARRAY) | (1 << expressParser.ASIN) | (1 << expressParser.ATAN) | (1 << expressParser.BLENGTH) | (1 << expressParser.CONST_E) | (1 << expressParser.COS))) != 0) or ((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & ((1 << (expressParser.EXISTS - 74)) | (1 << (expressParser.EXP - 74)) | (1 << (expressParser.FALSE - 74)) | (1 << (expressParser.FORMAT - 74)) | (1 << (expressParser.HIBOUND - 74)) | (1 << (expressParser.HIINDEX - 74)) | (1 << (expressParser.INSERT - 74)) | (1 << (expressParser.LENGTH - 74)) | (1 << (expressParser.LOBOUND - 74)) | (1 << (expressParser.LOINDEX - 74)) | (1 << (expressParser.LOG - 74)) | (1 << (expressParser.LOG2 - 74)) | (1 << (expressParser.LOG10 - 74)) | (1 << (expressParser.NOT - 74)) | (1 << (expressParser.NVL - 74)) | (1 << (expressParser.ODD - 74)) | (1 << (expressParser.PI - 74)) | (1 << (expressParser.QUERY - 74)) | (1 << (expressParser.REMOVE - 74)) | (1 << (expressParser.ROLESOF - 74)) | (1 << (expressParser.SELF - 74)) | (1 << (expressParser.SIN - 74)) | (1 << (expressParser.SIZEOF - 74)) | (1 << (expressParser.SQRT - 74)) | (1 << (expressParser.TAN - 74)) | (1 << (expressParser.TRUE - 74)) | (1 << (expressParser.TYPEOF - 74)))) != 0) or ((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (expressParser.USEDIN - 141)) | (1 << (expressParser.VALUE - 141)) | (1 << (expressParser.SimpleId - 141)) | (1 << (expressParser.Path - 141)) | (1 << (expressParser.IntegerLiteral - 141)) | (1 << (expressParser.BinaryLiteral - 141)) | (1 << (expressParser.LogicalLiteral - 141)) | (1 << (expressParser.RealLiteral - 141)) | (1 << (expressParser.StringLiteral - 141)))) != 0):
                self.state = 483
                self.caseAction()
                self.state = 488
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 490
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.OTHERWISE:
                self.state = 489
                self.otherAction()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseLabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_caseLabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseLabel" ):
                listener.enterCaseLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseLabel" ):
                listener.exitCaseLabel(self)




    def caseLabel(self):

        localctx = expressParser.CaseLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_caseLabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 492
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(expressParser.CASE, 0)

        def selector(self):
            return self.getTypedRuleContext(expressParser.SelectorContext,0)


        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def caseBody(self):
            return self.getTypedRuleContext(expressParser.CaseBodyContext,0)


        def END_CASE(self):
            return self.getToken(expressParser.END_CASE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_caseStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStmt" ):
                listener.enterCaseStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStmt" ):
                listener.exitCaseStmt(self)




    def caseStmt(self):

        localctx = expressParser.CaseStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_caseStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 494
            self.match(expressParser.CASE)
            self.state = 495
            self.selector()
            self.state = 496
            self.match(expressParser.OF)
            self.state = 497
            self.caseBody()
            self.state = 498
            self.match(expressParser.END_CASE)
            self.state = 499
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChoiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONEOF(self):
            return self.getToken(expressParser.ONEOF, 0)

        def supertypeExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.SupertypeExprContext)
            else:
                return self.getTypedRuleContext(expressParser.SupertypeExprContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChoice" ):
                listener.enterChoice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChoice" ):
                listener.exitChoice(self)




    def choice(self):

        localctx = expressParser.ChoiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_choice)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.match(expressParser.ONEOF)
            self.state = 502
            self.match(expressParser.T__0)
            self.state = 503
            self.supertypeExpr()
            self.state = 508
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 504
                self.match(expressParser.T__2)
                self.state = 505
                self.supertypeExpr()
                self.state = 510
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 511
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arrayType(self):
            return self.getTypedRuleContext(expressParser.ArrayTypeContext,0)


        def bagType(self):
            return self.getTypedRuleContext(expressParser.BagTypeContext,0)


        def listType(self):
            return self.getTypedRuleContext(expressParser.ListTypeContext,0)


        def setType(self):
            return self.getTypedRuleContext(expressParser.SetTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_collectionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionType" ):
                listener.enterCollectionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionType" ):
                listener.exitCollectionType(self)




    def collectionType(self):

        localctx = expressParser.CollectionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_collectionType)
        try:
            self.state = 517
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.ARRAY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 513
                self.arrayType()
                pass
            elif token in [expressParser.BAG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 514
                self.bagType()
                pass
            elif token in [expressParser.LIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 515
                self.listType()
                pass
            elif token in [expressParser.SET]:
                self.enterOuterAlt(localctx, 4)
                self.state = 516
                self.setType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionTypeSelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def collectionType(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeContext,0)


        def namedType(self):
            return self.getTypedRuleContext(expressParser.NamedTypeContext,0)


        def simpleType(self):
            return self.getTypedRuleContext(expressParser.SimpleTypeContext,0)


        def genericType(self):
            return self.getTypedRuleContext(expressParser.GenericTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_collectionTypeSel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionTypeSel" ):
                listener.enterCollectionTypeSel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionTypeSel" ):
                listener.exitCollectionTypeSel(self)




    def collectionTypeSel(self):

        localctx = expressParser.CollectionTypeSelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_collectionTypeSel)
        try:
            self.state = 523
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.ARRAY, expressParser.BAG, expressParser.LIST, expressParser.SET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 519
                self.collectionType()
                pass
            elif token in [expressParser.SimpleId]:
                self.enterOuterAlt(localctx, 2)
                self.state = 520
                self.namedType()
                pass
            elif token in [expressParser.BINARY, expressParser.BOOLEAN, expressParser.INTEGER, expressParser.LOGICAL, expressParser.NUMBER, expressParser.REAL, expressParser.STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 521
                self.simpleType()
                pass
            elif token in [expressParser.GENERIC]:
                self.enterOuterAlt(localctx, 4)
                self.state = 522
                self.genericType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN(self):
            return self.getToken(expressParser.BEGIN, 0)

        def stmts(self):
            return self.getTypedRuleContext(expressParser.StmtsContext,0)


        def END(self):
            return self.getToken(expressParser.END, 0)

        def getRuleIndex(self):
            return expressParser.RULE_compoundStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundStmt" ):
                listener.enterCompoundStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundStmt" ):
                listener.exitCompoundStmt(self)




    def compoundStmt(self):

        localctx = expressParser.CompoundStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_compoundStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            self.match(expressParser.BEGIN)
            self.state = 526
            self.stmts()
            self.state = 527
            self.match(expressParser.END)
            self.state = 528
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConformantArrayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(expressParser.ARRAY, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def allTypeSel(self):
            return self.getTypedRuleContext(expressParser.AllTypeSelContext,0)


        def OPTIONAL(self):
            return self.getToken(expressParser.OPTIONAL, 0)

        def UNIQUE(self):
            return self.getToken(expressParser.UNIQUE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_conformantArray

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConformantArray" ):
                listener.enterConformantArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConformantArray" ):
                listener.exitConformantArray(self)




    def conformantArray(self):

        localctx = expressParser.ConformantArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_conformantArray)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 530
            self.match(expressParser.ARRAY)
            self.state = 531
            self.match(expressParser.OF)
            self.state = 533
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.OPTIONAL:
                self.state = 532
                self.match(expressParser.OPTIONAL)


            self.state = 536
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.UNIQUE:
                self.state = 535
                self.match(expressParser.UNIQUE)


            self.state = 538
            self.allTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConformantBagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BAG(self):
            return self.getToken(expressParser.BAG, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def allTypeSel(self):
            return self.getTypedRuleContext(expressParser.AllTypeSelContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_conformantBag

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConformantBag" ):
                listener.enterConformantBag(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConformantBag" ):
                listener.exitConformantBag(self)




    def conformantBag(self):

        localctx = expressParser.ConformantBagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_conformantBag)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.match(expressParser.BAG)
            self.state = 541
            self.match(expressParser.OF)
            self.state = 542
            self.allTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConformantListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIST(self):
            return self.getToken(expressParser.LIST, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def allTypeSel(self):
            return self.getTypedRuleContext(expressParser.AllTypeSelContext,0)


        def UNIQUE(self):
            return self.getToken(expressParser.UNIQUE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_conformantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConformantList" ):
                listener.enterConformantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConformantList" ):
                listener.exitConformantList(self)




    def conformantList(self):

        localctx = expressParser.ConformantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_conformantList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 544
            self.match(expressParser.LIST)
            self.state = 545
            self.match(expressParser.OF)
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.UNIQUE:
                self.state = 546
                self.match(expressParser.UNIQUE)


            self.state = 549
            self.allTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConformantSetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(expressParser.SET, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def allTypeSel(self):
            return self.getTypedRuleContext(expressParser.AllTypeSelContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_conformantSet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConformantSet" ):
                listener.enterConformantSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConformantSet" ):
                listener.exitConformantSet(self)




    def conformantSet(self):

        localctx = expressParser.ConformantSetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_conformantSet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.match(expressParser.SET)
            self.state = 552
            self.match(expressParser.OF)
            self.state = 553
            self.allTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConformantTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conformantArray(self):
            return self.getTypedRuleContext(expressParser.ConformantArrayContext,0)


        def conformantBag(self):
            return self.getTypedRuleContext(expressParser.ConformantBagContext,0)


        def conformantList(self):
            return self.getTypedRuleContext(expressParser.ConformantListContext,0)


        def conformantSet(self):
            return self.getTypedRuleContext(expressParser.ConformantSetContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_conformantType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConformantType" ):
                listener.enterConformantType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConformantType" ):
                listener.exitConformantType(self)




    def conformantType(self):

        localctx = expressParser.ConformantTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_conformantType)
        try:
            self.state = 559
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.ARRAY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 555
                self.conformantArray()
                pass
            elif token in [expressParser.BAG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 556
                self.conformantBag()
                pass
            elif token in [expressParser.LIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 557
                self.conformantList()
                pass
            elif token in [expressParser.SET]:
                self.enterOuterAlt(localctx, 4)
                self.state = 558
                self.conformantSet()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTANT(self):
            return self.getToken(expressParser.CONSTANT, 0)

        def END_CONSTANT(self):
            return self.getToken(expressParser.END_CONSTANT, 0)

        def constBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ConstBodyContext)
            else:
                return self.getTypedRuleContext(expressParser.ConstBodyContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_constantDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantDecl" ):
                listener.enterConstantDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantDecl" ):
                listener.exitConstantDecl(self)




    def constantDecl(self):

        localctx = expressParser.ConstantDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_constantDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 561
            self.match(expressParser.CONSTANT)
            self.state = 565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.SimpleId:
                self.state = 562
                self.constBody()
                self.state = 567
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 568
            self.match(expressParser.END_CONSTANT)
            self.state = 569
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_constantRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantRef" ):
                listener.enterConstantRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantRef" ):
                listener.exitConstantRef(self)




    def constantRef(self):

        localctx = expressParser.ConstantRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_constantRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 571
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDef(self):
            return self.getTypedRuleContext(expressParser.ConstDefContext,0)


        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def init(self):
            return self.getTypedRuleContext(expressParser.InitContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_constBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstBody" ):
                listener.enterConstBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstBody" ):
                listener.exitConstBody(self)




    def constBody(self):

        localctx = expressParser.ConstBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_constBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self.constDef()
            self.state = 574
            self.match(expressParser.T__6)
            self.state = 575
            self.collectionTypeSel()
            self.state = 576
            self.init()
            self.state = 577
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_constDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDef" ):
                listener.enterConstDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDef" ):
                listener.exitConstDef(self)




    def constDef(self):

        localctx = expressParser.ConstDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_constDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDef(self):
            return self.getTypedRuleContext(expressParser.ConstDefContext,0)


        def stdConst(self):
            return self.getTypedRuleContext(expressParser.StdConstContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_constRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstRef" ):
                listener.enterConstRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstRef" ):
                listener.exitConstRef(self)




    def constRef(self):

        localctx = expressParser.ConstRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_constRef)
        try:
            self.state = 583
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.SimpleId]:
                self.enterOuterAlt(localctx, 1)
                self.state = 581
                self.constDef()
                pass
            elif token in [expressParser.T__29, expressParser.CONST_E, expressParser.PI, expressParser.SELF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 582
                self.stdConst()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityDecl(self):
            return self.getTypedRuleContext(expressParser.EntityDeclContext,0)


        def functionDecl(self):
            return self.getTypedRuleContext(expressParser.FunctionDeclContext,0)


        def procedureDecl(self):
            return self.getTypedRuleContext(expressParser.ProcedureDeclContext,0)


        def typeDecl(self):
            return self.getTypedRuleContext(expressParser.TypeDeclContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = expressParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_declaration)
        try:
            self.state = 589
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.ENTITY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 585
                self.entityDecl()
                pass
            elif token in [expressParser.FUNCTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 586
                self.functionDecl()
                pass
            elif token in [expressParser.PROCEDURE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 587
                self.procedureDecl()
                pass
            elif token in [expressParser.TYPE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 588
                self.typeDecl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeriveClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DERIVE(self):
            return self.getToken(expressParser.DERIVE, 0)

        def derivedAttr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.DerivedAttrContext)
            else:
                return self.getTypedRuleContext(expressParser.DerivedAttrContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_deriveClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeriveClause" ):
                listener.enterDeriveClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeriveClause" ):
                listener.exitDeriveClause(self)




    def deriveClause(self):

        localctx = expressParser.DeriveClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_deriveClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 591
            self.match(expressParser.DERIVE)
            self.state = 593 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 592
                self.derivedAttr()
                self.state = 595 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==expressParser.SimpleId or _la==expressParser.Path):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeriveDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrDef(self):
            return self.getTypedRuleContext(expressParser.AttrDefContext,0)


        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def init(self):
            return self.getTypedRuleContext(expressParser.InitContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_deriveDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeriveDef" ):
                listener.enterDeriveDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeriveDef" ):
                listener.exitDeriveDef(self)




    def deriveDef(self):

        localctx = expressParser.DeriveDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_deriveDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 597
            self.attrDef()
            self.state = 598
            self.match(expressParser.T__6)
            self.state = 599
            self.collectionTypeSel()
            self.state = 600
            self.init()
            self.state = 601
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DerivedAttrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deriveDef(self):
            return self.getTypedRuleContext(expressParser.DeriveDefContext,0)


        def derivedRedef(self):
            return self.getTypedRuleContext(expressParser.DerivedRedefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_derivedAttr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerivedAttr" ):
                listener.enterDerivedAttr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerivedAttr" ):
                listener.exitDerivedAttr(self)




    def derivedAttr(self):

        localctx = expressParser.DerivedAttrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_derivedAttr)
        try:
            self.state = 605
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 603
                self.deriveDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 604
                self.derivedRedef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DerivedRedefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrRef(self):
            return self.getTypedRuleContext(expressParser.AttrRefContext,0)


        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def init(self):
            return self.getTypedRuleContext(expressParser.InitContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_derivedRedef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerivedRedef" ):
                listener.enterDerivedRedef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerivedRedef" ):
                listener.exitDerivedRedef(self)




    def derivedRedef(self):

        localctx = expressParser.DerivedRedefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_derivedRedef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 607
            self.attrRef()
            self.state = 608
            self.match(expressParser.T__6)
            self.state = 609
            self.collectionTypeSel()
            self.state = 610
            self.init()
            self.state = 611
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DerivedPathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def Path(self):
            return self.getToken(expressParser.Path, 0)

        def getRuleIndex(self):
            return expressParser.RULE_derivedPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerivedPath" ):
                listener.enterDerivedPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerivedPath" ):
                listener.exitDerivedPath(self)




    def derivedPath(self):

        localctx = expressParser.DerivedPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_derivedPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 613
            self.expression()
            self.state = 614
            self.match(expressParser.T__10)
            self.state = 615
            self.match(expressParser.Path)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomainRuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelDef(self):
            return self.getTypedRuleContext(expressParser.LabelDefContext,0)


        def logicalExpr(self):
            return self.getTypedRuleContext(expressParser.LogicalExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_domainRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomainRule" ):
                listener.enterDomainRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomainRule" ):
                listener.exitDomainRule(self)




    def domainRule(self):

        localctx = expressParser.DomainRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_domainRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.labelDef()
            self.state = 618
            self.match(expressParser.T__6)
            self.state = 619
            self.logicalExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomainRulesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(expressParser.WHERE, 0)

        def domainRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.DomainRuleContext)
            else:
                return self.getTypedRuleContext(expressParser.DomainRuleContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_domainRules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomainRules" ):
                listener.enterDomainRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomainRules" ):
                listener.exitDomainRules(self)




    def domainRules(self):

        localctx = expressParser.DomainRulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_domainRules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 621
            self.match(expressParser.WHERE)
            self.state = 625 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 622
                self.domainRule()
                self.state = 623
                self.match(expressParser.T__7)
                self.state = 627 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==expressParser.SimpleId):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def repetition(self):
            return self.getTypedRuleContext(expressParser.RepetitionContext,0)


        def StringLiteral(self):
            return self.getToken(expressParser.StringLiteral, 0)

        def RealLiteral(self):
            return self.getToken(expressParser.RealLiteral, 0)

        def derivedPath(self):
            return self.getTypedRuleContext(expressParser.DerivedPathContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement" ):
                listener.enterElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement" ):
                listener.exitElement(self)




    def element(self):

        localctx = expressParser.ElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_element)
        try:
            self.state = 637
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 629
                self.expression()
                self.state = 630
                self.match(expressParser.T__6)
                self.state = 631
                self.repetition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 633
                self.match(expressParser.StringLiteral)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 634
                self.match(expressParser.RealLiteral)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 635
                self.expression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 636
                self.derivedPath()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmbeddedRemarkContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def embeddedRemark(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.EmbeddedRemarkContext)
            else:
                return self.getTypedRuleContext(expressParser.EmbeddedRemarkContext,i)


        def remarkStuff(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.RemarkStuffContext)
            else:
                return self.getTypedRuleContext(expressParser.RemarkStuffContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_embeddedRemark

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmbeddedRemark" ):
                listener.enterEmbeddedRemark(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmbeddedRemark" ):
                listener.exitEmbeddedRemark(self)




    def embeddedRemark(self):

        localctx = expressParser.EmbeddedRemarkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_embeddedRemark)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            self.match(expressParser.T__11)
            self.state = 644
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 642
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                    if la_ == 1:
                        self.state = 640
                        self.embeddedRemark()
                        pass

                    elif la_ == 2:
                        self.state = 641
                        self.remarkStuff()
                        pass

             
                self.state = 646
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

            self.state = 647
            self.match(expressParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntityBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attributes(self):
            return self.getTypedRuleContext(expressParser.AttributesContext,0)


        def localRules(self):
            return self.getTypedRuleContext(expressParser.LocalRulesContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_entityBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntityBody" ):
                listener.enterEntityBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntityBody" ):
                listener.exitEntityBody(self)




    def entityBody(self):

        localctx = expressParser.EntityBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_entityBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self.attributes()
            self.state = 650
            self.localRules()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntityDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityHead(self):
            return self.getTypedRuleContext(expressParser.EntityHeadContext,0)


        def entityBody(self):
            return self.getTypedRuleContext(expressParser.EntityBodyContext,0)


        def END_ENTITY(self):
            return self.getToken(expressParser.END_ENTITY, 0)

        def getRuleIndex(self):
            return expressParser.RULE_entityDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntityDecl" ):
                listener.enterEntityDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntityDecl" ):
                listener.exitEntityDecl(self)




    def entityDecl(self):

        localctx = expressParser.EntityDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_entityDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 652
            self.entityHead()
            self.state = 653
            self.entityBody()
            self.state = 654
            self.match(expressParser.END_ENTITY)
            self.state = 655
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntityDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_entityDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntityDef" ):
                listener.enterEntityDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntityDef" ):
                listener.exitEntityDef(self)




    def entityDef(self):

        localctx = expressParser.EntityDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_entityDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntityHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTITY(self):
            return self.getToken(expressParser.ENTITY, 0)

        def entityDef(self):
            return self.getTypedRuleContext(expressParser.EntityDefContext,0)


        def subSuper(self):
            return self.getTypedRuleContext(expressParser.SubSuperContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_entityHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntityHead" ):
                listener.enterEntityHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntityHead" ):
                listener.exitEntityHead(self)




    def entityHead(self):

        localctx = expressParser.EntityHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_entityHead)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.match(expressParser.ENTITY)
            self.state = 660
            self.entityDef()
            self.state = 661
            self.subSuper()
            self.state = 662
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntityLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(expressParser.ExpressionContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_entityLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntityLiteral" ):
                listener.enterEntityLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntityLiteral" ):
                listener.exitEntityLiteral(self)




    def entityLiteral(self):

        localctx = expressParser.EntityLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_entityLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 664
            self.entityRef()
            self.state = 665
            self.match(expressParser.T__0)
            self.state = 674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__0) | (1 << expressParser.T__4) | (1 << expressParser.T__23) | (1 << expressParser.T__27) | (1 << expressParser.T__28) | (1 << expressParser.T__29) | (1 << expressParser.ABS) | (1 << expressParser.ACOS) | (1 << expressParser.ARRAY) | (1 << expressParser.ASIN) | (1 << expressParser.ATAN) | (1 << expressParser.BLENGTH) | (1 << expressParser.CONST_E) | (1 << expressParser.COS))) != 0) or ((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & ((1 << (expressParser.EXISTS - 74)) | (1 << (expressParser.EXP - 74)) | (1 << (expressParser.FALSE - 74)) | (1 << (expressParser.FORMAT - 74)) | (1 << (expressParser.HIBOUND - 74)) | (1 << (expressParser.HIINDEX - 74)) | (1 << (expressParser.INSERT - 74)) | (1 << (expressParser.LENGTH - 74)) | (1 << (expressParser.LOBOUND - 74)) | (1 << (expressParser.LOINDEX - 74)) | (1 << (expressParser.LOG - 74)) | (1 << (expressParser.LOG2 - 74)) | (1 << (expressParser.LOG10 - 74)) | (1 << (expressParser.NOT - 74)) | (1 << (expressParser.NVL - 74)) | (1 << (expressParser.ODD - 74)) | (1 << (expressParser.PI - 74)) | (1 << (expressParser.QUERY - 74)) | (1 << (expressParser.REMOVE - 74)) | (1 << (expressParser.ROLESOF - 74)) | (1 << (expressParser.SELF - 74)) | (1 << (expressParser.SIN - 74)) | (1 << (expressParser.SIZEOF - 74)) | (1 << (expressParser.SQRT - 74)) | (1 << (expressParser.TAN - 74)) | (1 << (expressParser.TRUE - 74)) | (1 << (expressParser.TYPEOF - 74)))) != 0) or ((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (expressParser.USEDIN - 141)) | (1 << (expressParser.VALUE - 141)) | (1 << (expressParser.SimpleId - 141)) | (1 << (expressParser.Path - 141)) | (1 << (expressParser.IntegerLiteral - 141)) | (1 << (expressParser.BinaryLiteral - 141)) | (1 << (expressParser.LogicalLiteral - 141)) | (1 << (expressParser.RealLiteral - 141)) | (1 << (expressParser.StringLiteral - 141)))) != 0):
                self.state = 666
                self.expression()
                self.state = 671
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==expressParser.T__2:
                    self.state = 667
                    self.match(expressParser.T__2)
                    self.state = 668
                    self.expression()
                    self.state = 673
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 676
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntityRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_entityRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntityRef" ):
                listener.enterEntityRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntityRef" ):
                listener.exitEntityRef(self)




    def entityRef(self):

        localctx = expressParser.EntityRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_entityRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_enumDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumDef" ):
                listener.enterEnumDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumDef" ):
                listener.exitEnumDef(self)




    def enumDef(self):

        localctx = expressParser.EnumDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_enumDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 680
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumDef(self):
            return self.getTypedRuleContext(expressParser.EnumDefContext,0)


        def typeRef(self):
            return self.getTypedRuleContext(expressParser.TypeRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_enumRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumRef" ):
                listener.enterEnumRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumRef" ):
                listener.exitEnumRef(self)




    def enumRef(self):

        localctx = expressParser.EnumRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_enumRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 682
                self.typeRef()
                self.state = 683
                self.match(expressParser.T__13)


            self.state = 687
            self.enumDef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATION(self):
            return self.getToken(expressParser.ENUMERATION, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def enumValues(self):
            return self.getTypedRuleContext(expressParser.EnumValuesContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_enumType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumType" ):
                listener.enterEnumType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumType" ):
                listener.exitEnumType(self)




    def enumType(self):

        localctx = expressParser.EnumTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_enumType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 689
            self.match(expressParser.ENUMERATION)
            self.state = 690
            self.match(expressParser.OF)
            self.state = 691
            self.match(expressParser.T__0)
            self.state = 692
            self.enumValues()
            self.state = 693
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumValuesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.EnumDefContext)
            else:
                return self.getTypedRuleContext(expressParser.EnumDefContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_enumValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumValues" ):
                listener.enterEnumValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumValues" ):
                listener.exitEnumValues(self)




    def enumValues(self):

        localctx = expressParser.EnumValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_enumValues)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 695
            self.enumDef()
            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 696
                self.match(expressParser.T__2)
                self.state = 697
                self.enumDef()
                self.state = 702
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscapeStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ESCAPE(self):
            return self.getToken(expressParser.ESCAPE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_escapeStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscapeStmt" ):
                listener.enterEscapeStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscapeStmt" ):
                listener.exitEscapeStmt(self)




    def escapeStmt(self):

        localctx = expressParser.EscapeStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_escapeStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 703
            self.match(expressParser.ESCAPE)
            self.state = 704
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.AttrDefContext)
            else:
                return self.getTypedRuleContext(expressParser.AttrDefContext,i)


        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def OPTIONAL(self):
            return self.getToken(expressParser.OPTIONAL, 0)

        def getRuleIndex(self):
            return expressParser.RULE_explDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplDef" ):
                listener.enterExplDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplDef" ):
                listener.exitExplDef(self)




    def explDef(self):

        localctx = expressParser.ExplDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_explDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.attrDef()
            self.state = 711
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 707
                self.match(expressParser.T__2)
                self.state = 708
                self.attrDef()
                self.state = 713
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 714
            self.match(expressParser.T__6)
            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.OPTIONAL:
                self.state = 715
                self.match(expressParser.OPTIONAL)


            self.state = 718
            self.collectionTypeSel()
            self.state = 719
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplicitClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def explDef(self):
            return self.getTypedRuleContext(expressParser.ExplDefContext,0)


        def explRedef(self):
            return self.getTypedRuleContext(expressParser.ExplRedefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_explicitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplicitClause" ):
                listener.enterExplicitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplicitClause" ):
                listener.exitExplicitClause(self)




    def explicitClause(self):

        localctx = expressParser.ExplicitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_explicitClause)
        try:
            self.state = 723
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 721
                self.explDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 722
                self.explRedef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplRedefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrRef(self):
            return self.getTypedRuleContext(expressParser.AttrRefContext,0)


        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def OPTIONAL(self):
            return self.getToken(expressParser.OPTIONAL, 0)

        def getRuleIndex(self):
            return expressParser.RULE_explRedef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplRedef" ):
                listener.enterExplRedef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplRedef" ):
                listener.exitExplRedef(self)




    def explRedef(self):

        localctx = expressParser.ExplRedefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_explRedef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 725
            self.attrRef()
            self.state = 726
            self.match(expressParser.T__6)
            self.state = 728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.OPTIONAL:
                self.state = 727
                self.match(expressParser.OPTIONAL)


            self.state = 730
            self.collectionTypeSel()
            self.state = 731
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(expressParser.SimpleExprContext,i)


        def IN(self):
            return self.getToken(expressParser.IN, 0)

        def LIKE(self):
            return self.getToken(expressParser.LIKE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = expressParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 733
            self.simpleExpr()
            self.state = 736
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__14) | (1 << expressParser.T__15) | (1 << expressParser.T__16) | (1 << expressParser.T__17) | (1 << expressParser.T__18) | (1 << expressParser.T__19) | (1 << expressParser.T__20) | (1 << expressParser.T__21))) != 0) or _la==expressParser.IN or _la==expressParser.LIKE:
                self.state = 734
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__14) | (1 << expressParser.T__15) | (1 << expressParser.T__16) | (1 << expressParser.T__17) | (1 << expressParser.T__18) | (1 << expressParser.T__19) | (1 << expressParser.T__20) | (1 << expressParser.T__21))) != 0) or _la==expressParser.IN or _la==expressParser.LIKE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 735
                self.simpleExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleFactor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.SimpleFactorContext)
            else:
                return self.getTypedRuleContext(expressParser.SimpleFactorContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)




    def factor(self):

        localctx = expressParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_factor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            self.simpleFactor()
            self.state = 741
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__22:
                self.state = 739
                self.match(expressParser.T__22)
                self.state = 740
                self.simpleFactor()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParamContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ParamDefContext)
            else:
                return self.getTypedRuleContext(expressParser.ParamDefContext,i)


        def returnTypeChoice(self):
            return self.getTypedRuleContext(expressParser.ReturnTypeChoiceContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_formalParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParam" ):
                listener.enterFormalParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParam" ):
                listener.exitFormalParam(self)




    def formalParam(self):

        localctx = expressParser.FormalParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_formalParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 743
            self.paramDef()
            self.state = 748
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 744
                self.match(expressParser.T__2)
                self.state = 745
                self.paramDef()
                self.state = 750
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 751
            self.match(expressParser.T__6)
            self.state = 752
            self.returnTypeChoice()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParamsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formalParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.FormalParamContext)
            else:
                return self.getTypedRuleContext(expressParser.FormalParamContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_formalParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParams" ):
                listener.enterFormalParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParams" ):
                listener.exitFormalParams(self)




    def formalParams(self):

        localctx = expressParser.FormalParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_formalParams)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self.match(expressParser.T__0)
            self.state = 755
            self.formalParam()
            self.state = 760
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__7:
                self.state = 756
                self.match(expressParser.T__7)
                self.state = 757
                self.formalParam()
                self.state = 762
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 763
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_funcDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncDef" ):
                listener.enterFuncDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncDef" ):
                listener.exitFuncDef(self)




    def funcDef(self):

        localctx = expressParser.FuncDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_funcDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 765
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(expressParser.FUNCTION, 0)

        def funcDef(self):
            return self.getTypedRuleContext(expressParser.FuncDefContext,0)


        def returnTypeChoice(self):
            return self.getTypedRuleContext(expressParser.ReturnTypeChoiceContext,0)


        def formalParams(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.FormalParamsContext)
            else:
                return self.getTypedRuleContext(expressParser.FormalParamsContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_funcHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncHead" ):
                listener.enterFuncHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncHead" ):
                listener.exitFuncHead(self)




    def funcHead(self):

        localctx = expressParser.FuncHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_funcHead)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.match(expressParser.FUNCTION)
            self.state = 768
            self.funcDef()
            self.state = 772
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__0:
                self.state = 769
                self.formalParams()
                self.state = 774
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 775
            self.match(expressParser.T__6)
            self.state = 776
            self.returnTypeChoice()
            self.state = 777
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnTypeChoiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def allTypeSel(self):
            return self.getTypedRuleContext(expressParser.AllTypeSelContext,0)


        def collectionType(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_returnTypeChoice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnTypeChoice" ):
                listener.enterReturnTypeChoice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnTypeChoice" ):
                listener.exitReturnTypeChoice(self)




    def returnTypeChoice(self):

        localctx = expressParser.ReturnTypeChoiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_returnTypeChoice)
        try:
            self.state = 781
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 779
                self.allTypeSel()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 780
                self.collectionType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actualParams(self):
            return self.getTypedRuleContext(expressParser.ActualParamsContext,0)


        def funcDef(self):
            return self.getTypedRuleContext(expressParser.FuncDefContext,0)


        def stdFunc(self):
            return self.getTypedRuleContext(expressParser.StdFuncContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_funcRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRef" ):
                listener.enterFuncRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRef" ):
                listener.exitFuncRef(self)




    def funcRef(self):

        localctx = expressParser.FuncRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_funcRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 785
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.SimpleId]:
                self.state = 783
                self.funcDef()
                pass
            elif token in [expressParser.ABS, expressParser.ACOS, expressParser.ASIN, expressParser.ATAN, expressParser.BLENGTH, expressParser.COS, expressParser.EXISTS, expressParser.EXP, expressParser.FORMAT, expressParser.HIBOUND, expressParser.HIINDEX, expressParser.LENGTH, expressParser.LOBOUND, expressParser.LOINDEX, expressParser.LOG, expressParser.LOG2, expressParser.LOG10, expressParser.NVL, expressParser.ODD, expressParser.ROLESOF, expressParser.SIN, expressParser.SIZEOF, expressParser.SQRT, expressParser.TAN, expressParser.TYPEOF, expressParser.USEDIN, expressParser.VALUE]:
                self.state = 784
                self.stdFunc()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 787
            self.actualParams()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funcHead(self):
            return self.getTypedRuleContext(expressParser.FuncHeadContext,0)


        def prolog(self):
            return self.getTypedRuleContext(expressParser.PrologContext,0)


        def stmts(self):
            return self.getTypedRuleContext(expressParser.StmtsContext,0)


        def END_FUNCTION(self):
            return self.getToken(expressParser.END_FUNCTION, 0)

        def getRuleIndex(self):
            return expressParser.RULE_functionDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDecl" ):
                listener.enterFunctionDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDecl" ):
                listener.exitFunctionDecl(self)




    def functionDecl(self):

        localctx = expressParser.FunctionDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_functionDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 789
            self.funcHead()
            self.state = 790
            self.prolog()
            self.state = 791
            self.stmts()
            self.state = 792
            self.match(expressParser.END_FUNCTION)
            self.state = 793
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERIC(self):
            return self.getToken(expressParser.GENERIC, 0)

        def typeLabel(self):
            return self.getTypedRuleContext(expressParser.TypeLabelContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_genericType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericType" ):
                listener.enterGenericType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericType" ):
                listener.exitGenericType(self)




    def genericType(self):

        localctx = expressParser.GenericTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_genericType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self.match(expressParser.GENERIC)
            self.state = 798
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.state = 796
                self.match(expressParser.T__6)
                self.state = 797
                self.typeLabel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(expressParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def THEN(self):
            return self.getToken(expressParser.THEN, 0)

        def stmts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.StmtsContext)
            else:
                return self.getTypedRuleContext(expressParser.StmtsContext,i)


        def END_IF(self):
            return self.getToken(expressParser.END_IF, 0)

        def ELSE(self):
            return self.getToken(expressParser.ELSE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_ifStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStmt" ):
                listener.enterIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStmt" ):
                listener.exitIfStmt(self)




    def ifStmt(self):

        localctx = expressParser.IfStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_ifStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 800
            self.match(expressParser.IF)
            self.state = 801
            self.expression()
            self.state = 802
            self.match(expressParser.THEN)
            self.state = 803
            self.stmts()
            self.state = 806
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.ELSE:
                self.state = 804
                self.match(expressParser.ELSE)
                self.state = 805
                self.stmts()


            self.state = 808
            self.match(expressParser.END_IF)
            self.state = 809
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportEntityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def AS(self):
            return self.getToken(expressParser.AS, 0)

        def entityDef(self):
            return self.getTypedRuleContext(expressParser.EntityDefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_importEntity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportEntity" ):
                listener.enterImportEntity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportEntity" ):
                listener.exitImportEntity(self)




    def importEntity(self):

        localctx = expressParser.ImportEntityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_importEntity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 811
            self.entityRef()
            self.state = 814
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.AS:
                self.state = 812
                self.match(expressParser.AS)
                self.state = 813
                self.entityDef()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importRef(self):
            return self.getTypedRuleContext(expressParser.ImportRefContext,0)


        def AS(self):
            return self.getToken(expressParser.AS, 0)

        def aliasDef(self):
            return self.getTypedRuleContext(expressParser.AliasDefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_importItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportItem" ):
                listener.enterImportItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportItem" ):
                listener.exitImportItem(self)




    def importItem(self):

        localctx = expressParser.ImportItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_importItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 816
            self.importRef()
            self.state = 819
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.AS:
                self.state = 817
                self.match(expressParser.AS)
                self.state = 818
                self.aliasDef()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ImportItemContext)
            else:
                return self.getTypedRuleContext(expressParser.ImportItemContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_importList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportList" ):
                listener.enterImportList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportList" ):
                listener.exitImportList(self)




    def importList(self):

        localctx = expressParser.ImportListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_importList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 821
            self.match(expressParser.T__0)
            self.state = 822
            self.importItem()
            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 823
                self.match(expressParser.T__2)
                self.state = 824
                self.importItem()
                self.state = 829
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 830
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantRef(self):
            return self.getTypedRuleContext(expressParser.ConstantRefContext,0)


        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def funcRef(self):
            return self.getTypedRuleContext(expressParser.FuncRefContext,0)


        def procRef(self):
            return self.getTypedRuleContext(expressParser.ProcRefContext,0)


        def typeRef(self):
            return self.getTypedRuleContext(expressParser.TypeRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_importRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportRef" ):
                listener.enterImportRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportRef" ):
                listener.exitImportRef(self)




    def importRef(self):

        localctx = expressParser.ImportRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_importRef)
        try:
            self.state = 837
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 832
                self.constantRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 833
                self.entityRef()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 834
                self.funcRef()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 835
                self.procRef()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 836
                self.typeRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self):
            return self.getTypedRuleContext(expressParser.NumberExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_incr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncr" ):
                listener.enterIncr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncr" ):
                listener.exitIncr(self)




    def incr(self):

        localctx = expressParser.IncrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_incr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 839
            self.numberExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncrementControlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDef(self):
            return self.getTypedRuleContext(expressParser.VarDefContext,0)


        def bound1(self):
            return self.getTypedRuleContext(expressParser.Bound1Context,0)


        def TO(self):
            return self.getToken(expressParser.TO, 0)

        def bound2(self):
            return self.getTypedRuleContext(expressParser.Bound2Context,0)


        def BY(self):
            return self.getToken(expressParser.BY, 0)

        def incr(self):
            return self.getTypedRuleContext(expressParser.IncrContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_incrementControl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncrementControl" ):
                listener.enterIncrementControl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncrementControl" ):
                listener.exitIncrementControl(self)




    def incrementControl(self):

        localctx = expressParser.IncrementControlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_incrementControl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 841
            self.varDef()
            self.state = 842
            self.match(expressParser.T__8)
            self.state = 843
            self.bound1()
            self.state = 844
            self.match(expressParser.TO)
            self.state = 845
            self.bound2()
            self.state = 848
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.BY:
                self.state = 846
                self.match(expressParser.BY)
                self.state = 847
                self.incr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def UNKNOWN(self):
            return self.getToken(expressParser.UNKNOWN, 0)

        def getRuleIndex(self):
            return expressParser.RULE_init

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInit" ):
                listener.enterInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInit" ):
                listener.exitInit(self)




    def init(self):

        localctx = expressParser.InitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_init)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 850
            self.match(expressParser.T__8)
            self.state = 854
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.T__0, expressParser.T__4, expressParser.T__23, expressParser.T__27, expressParser.T__28, expressParser.T__29, expressParser.ABS, expressParser.ACOS, expressParser.ARRAY, expressParser.ASIN, expressParser.ATAN, expressParser.BLENGTH, expressParser.CONST_E, expressParser.COS, expressParser.EXISTS, expressParser.EXP, expressParser.FALSE, expressParser.FORMAT, expressParser.HIBOUND, expressParser.HIINDEX, expressParser.INSERT, expressParser.LENGTH, expressParser.LOBOUND, expressParser.LOINDEX, expressParser.LOG, expressParser.LOG2, expressParser.LOG10, expressParser.NOT, expressParser.NVL, expressParser.ODD, expressParser.PI, expressParser.QUERY, expressParser.REMOVE, expressParser.ROLESOF, expressParser.SELF, expressParser.SIN, expressParser.SIZEOF, expressParser.SQRT, expressParser.TAN, expressParser.TRUE, expressParser.TYPEOF, expressParser.USEDIN, expressParser.VALUE, expressParser.SimpleId, expressParser.Path, expressParser.IntegerLiteral, expressParser.BinaryLiteral, expressParser.LogicalLiteral, expressParser.RealLiteral, expressParser.StringLiteral]:
                self.state = 851
                self.expression()
                pass
            elif token in [expressParser.T__9]:
                self.state = 852
                self.match(expressParser.T__9)
                pass
            elif token in [expressParser.UNKNOWN]:
                self.state = 853
                self.match(expressParser.UNKNOWN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(expressParser.INTEGER, 0)

        def getRuleIndex(self):
            return expressParser.RULE_integerType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerType" ):
                listener.enterIntegerType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerType" ):
                listener.exitIntegerType(self)




    def integerType(self):

        localctx = expressParser.IntegerTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_integerType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 856
            self.match(expressParser.INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceSpecificationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def referenceClause(self):
            return self.getTypedRuleContext(expressParser.ReferenceClauseContext,0)


        def useClause(self):
            return self.getTypedRuleContext(expressParser.UseClauseContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_interfaceSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceSpecification" ):
                listener.enterInterfaceSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceSpecification" ):
                listener.exitInterfaceSpecification(self)




    def interfaceSpecification(self):

        localctx = expressParser.InterfaceSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_interfaceSpecification)
        try:
            self.state = 860
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.REFERENCE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 858
                self.referenceClause()
                pass
            elif token in [expressParser.USE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 859
                self.useClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(expressParser.SimpleExprContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_interval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval" ):
                listener.enterInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval" ):
                listener.exitInterval(self)




    def interval(self):

        localctx = expressParser.IntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_interval)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 862
            self.match(expressParser.T__23)
            self.state = 863
            self.simpleExpr()
            self.state = 864
            _la = self._input.LA(1)
            if not(_la==expressParser.T__14 or _la==expressParser.T__16):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 865
            self.simpleExpr()
            self.state = 866
            _la = self._input.LA(1)
            if not(_la==expressParser.T__14 or _la==expressParser.T__16):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 867
            self.simpleExpr()
            self.state = 868
            self.match(expressParser.T__24)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InverseAttrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inverseDef(self):
            return self.getTypedRuleContext(expressParser.InverseDefContext,0)


        def inverseRedef(self):
            return self.getTypedRuleContext(expressParser.InverseRedefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_inverseAttr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseAttr" ):
                listener.enterInverseAttr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseAttr" ):
                listener.exitInverseAttr(self)




    def inverseAttr(self):

        localctx = expressParser.InverseAttrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_inverseAttr)
        try:
            self.state = 872
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 870
                self.inverseDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 871
                self.inverseRedef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InverseClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INVERSE(self):
            return self.getToken(expressParser.INVERSE, 0)

        def inverseAttr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.InverseAttrContext)
            else:
                return self.getTypedRuleContext(expressParser.InverseAttrContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_inverseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseClause" ):
                listener.enterInverseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseClause" ):
                listener.exitInverseClause(self)




    def inverseClause(self):

        localctx = expressParser.InverseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_inverseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self.match(expressParser.INVERSE)
            self.state = 878
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.SimpleId or _la==expressParser.Path:
                self.state = 875
                self.inverseAttr()
                self.state = 880
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InverseDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrDef(self):
            return self.getTypedRuleContext(expressParser.AttrDefContext,0)


        def inverseType(self):
            return self.getTypedRuleContext(expressParser.InverseTypeContext,0)


        def FOR(self):
            return self.getToken(expressParser.FOR, 0)

        def attrRef(self):
            return self.getTypedRuleContext(expressParser.AttrRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_inverseDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseDef" ):
                listener.enterInverseDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseDef" ):
                listener.exitInverseDef(self)




    def inverseDef(self):

        localctx = expressParser.InverseDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_inverseDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 881
            self.attrDef()
            self.state = 882
            self.match(expressParser.T__6)
            self.state = 883
            self.inverseType()
            self.state = 884
            self.match(expressParser.FOR)
            self.state = 885
            self.attrRef()
            self.state = 886
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InverseRedefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.AttrRefContext)
            else:
                return self.getTypedRuleContext(expressParser.AttrRefContext,i)


        def inverseType(self):
            return self.getTypedRuleContext(expressParser.InverseTypeContext,0)


        def FOR(self):
            return self.getToken(expressParser.FOR, 0)

        def getRuleIndex(self):
            return expressParser.RULE_inverseRedef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseRedef" ):
                listener.enterInverseRedef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseRedef" ):
                listener.exitInverseRedef(self)




    def inverseRedef(self):

        localctx = expressParser.InverseRedefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_inverseRedef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 888
            self.attrRef()
            self.state = 889
            self.match(expressParser.T__7)
            self.state = 890
            self.inverseType()
            self.state = 891
            self.match(expressParser.FOR)
            self.state = 892
            self.attrRef()
            self.state = 893
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InverseTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def SET(self):
            return self.getToken(expressParser.SET, 0)

        def BAG(self):
            return self.getToken(expressParser.BAG, 0)

        def boundSpec(self):
            return self.getTypedRuleContext(expressParser.BoundSpecContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_inverseType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseType" ):
                listener.enterInverseType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseType" ):
                listener.exitInverseType(self)




    def inverseType(self):

        localctx = expressParser.InverseTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_inverseType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 900
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.BAG or _la==expressParser.SET:
                self.state = 895
                _la = self._input.LA(1)
                if not(_la==expressParser.BAG or _la==expressParser.SET):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 897
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.T__4:
                    self.state = 896
                    self.boundSpec()


                self.state = 899
                self.match(expressParser.OF)


            self.state = 902
            self.entityRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_labelDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelDef" ):
                listener.enterLabelDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelDef" ):
                listener.exitLabelDef(self)




    def labelDef(self):

        localctx = expressParser.LabelDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_labelDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 904
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIST(self):
            return self.getToken(expressParser.LIST, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def boundSpec(self):
            return self.getTypedRuleContext(expressParser.BoundSpecContext,0)


        def UNIQUE(self):
            return self.getToken(expressParser.UNIQUE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_listType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListType" ):
                listener.enterListType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListType" ):
                listener.exitListType(self)




    def listType(self):

        localctx = expressParser.ListTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_listType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 906
            self.match(expressParser.LIST)
            self.state = 908
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__4:
                self.state = 907
                self.boundSpec()


            self.state = 910
            self.match(expressParser.OF)
            self.state = 912
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.UNIQUE:
                self.state = 911
                self.match(expressParser.UNIQUE)


            self.state = 914
            self.collectionTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BinaryLiteral(self):
            return self.getToken(expressParser.BinaryLiteral, 0)

        def IntegerLiteral(self):
            return self.getToken(expressParser.IntegerLiteral, 0)

        def LogicalLiteral(self):
            return self.getToken(expressParser.LogicalLiteral, 0)

        def RealLiteral(self):
            return self.getToken(expressParser.RealLiteral, 0)

        def StringLiteral(self):
            return self.getToken(expressParser.StringLiteral, 0)

        def aggregateLiteral(self):
            return self.getTypedRuleContext(expressParser.AggregateLiteralContext,0)


        def entityLiteral(self):
            return self.getTypedRuleContext(expressParser.EntityLiteralContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = expressParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_literal)
        try:
            self.state = 923
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.BinaryLiteral]:
                self.enterOuterAlt(localctx, 1)
                self.state = 916
                self.match(expressParser.BinaryLiteral)
                pass
            elif token in [expressParser.IntegerLiteral]:
                self.enterOuterAlt(localctx, 2)
                self.state = 917
                self.match(expressParser.IntegerLiteral)
                pass
            elif token in [expressParser.LogicalLiteral]:
                self.enterOuterAlt(localctx, 3)
                self.state = 918
                self.match(expressParser.LogicalLiteral)
                pass
            elif token in [expressParser.RealLiteral]:
                self.enterOuterAlt(localctx, 4)
                self.state = 919
                self.match(expressParser.RealLiteral)
                pass
            elif token in [expressParser.StringLiteral]:
                self.enterOuterAlt(localctx, 5)
                self.state = 920
                self.match(expressParser.StringLiteral)
                pass
            elif token in [expressParser.T__4]:
                self.enterOuterAlt(localctx, 6)
                self.state = 921
                self.aggregateLiteral()
                pass
            elif token in [expressParser.SimpleId]:
                self.enterOuterAlt(localctx, 7)
                self.state = 922
                self.entityLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCAL(self):
            return self.getToken(expressParser.LOCAL, 0)

        def END_LOCAL(self):
            return self.getToken(expressParser.END_LOCAL, 0)

        def localVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.LocalVarContext)
            else:
                return self.getTypedRuleContext(expressParser.LocalVarContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_localDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalDecl" ):
                listener.enterLocalDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalDecl" ):
                listener.exitLocalDecl(self)




    def localDecl(self):

        localctx = expressParser.LocalDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_localDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 925
            self.match(expressParser.LOCAL)
            self.state = 929
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.SimpleId:
                self.state = 926
                self.localVar()
                self.state = 931
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 932
            self.match(expressParser.END_LOCAL)
            self.state = 933
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalRulesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uniqueRules(self):
            return self.getTypedRuleContext(expressParser.UniqueRulesContext,0)


        def domainRules(self):
            return self.getTypedRuleContext(expressParser.DomainRulesContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_localRules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalRules" ):
                listener.enterLocalRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalRules" ):
                listener.exitLocalRules(self)




    def localRules(self):

        localctx = expressParser.LocalRulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_localRules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 936
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.UNIQUE:
                self.state = 935
                self.uniqueRules()


            self.state = 939
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.WHERE:
                self.state = 938
                self.domainRules()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalVarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.VarDefContext)
            else:
                return self.getTypedRuleContext(expressParser.VarDefContext,i)


        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def conformantType(self):
            return self.getTypedRuleContext(expressParser.ConformantTypeContext,0)


        def init(self):
            return self.getTypedRuleContext(expressParser.InitContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_localVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalVar" ):
                listener.enterLocalVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalVar" ):
                listener.exitLocalVar(self)




    def localVar(self):

        localctx = expressParser.LocalVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_localVar)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 941
            self.varDef()
            self.state = 946
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 942
                self.match(expressParser.T__2)
                self.state = 943
                self.varDef()
                self.state = 948
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 949
            self.match(expressParser.T__6)
            self.state = 952
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.state = 950
                self.collectionTypeSel()
                pass

            elif la_ == 2:
                self.state = 951
                self.conformantType()
                pass


            self.state = 955
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__8:
                self.state = 954
                self.init()


            self.state = 957
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_logicalExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)




    def logicalExpr(self):

        localctx = expressParser.LogicalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_logicalExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 959
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGICAL(self):
            return self.getToken(expressParser.LOGICAL, 0)

        def getRuleIndex(self):
            return expressParser.RULE_logicalType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalType" ):
                listener.enterLogicalType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalType" ):
                listener.exitLogicalType(self)




    def logicalType(self):

        localctx = expressParser.LogicalTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_logicalType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 961
            self.match(expressParser.LOGICAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def typeRef(self):
            return self.getTypedRuleContext(expressParser.TypeRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_namedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedType" ):
                listener.enterNamedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedType" ):
                listener.exitNamedType(self)




    def namedType(self):

        localctx = expressParser.NamedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_namedType)
        try:
            self.state = 965
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 963
                self.entityRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 964
                self.typeRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return expressParser.RULE_nullStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullStmt" ):
                listener.enterNullStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullStmt" ):
                listener.exitNullStmt(self)




    def nullStmt(self):

        localctx = expressParser.NullStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_nullStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 967
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self):
            return self.getTypedRuleContext(expressParser.SimpleExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_numberExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberExpr" ):
                listener.enterNumberExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberExpr" ):
                listener.exitNumberExpr(self)




    def numberExpr(self):

        localctx = expressParser.NumberExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_numberExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 969
            self.simpleExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(expressParser.NUMBER, 0)

        def getRuleIndex(self):
            return expressParser.RULE_numberType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberType" ):
                listener.enterNumberType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberType" ):
                listener.exitNumberType(self)




    def numberType(self):

        localctx = expressParser.NumberTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_numberType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 971
            self.match(expressParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OTHERWISE(self):
            return self.getToken(expressParser.OTHERWISE, 0)

        def stmt(self):
            return self.getTypedRuleContext(expressParser.StmtContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_otherAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOtherAction" ):
                listener.enterOtherAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOtherAction" ):
                listener.exitOtherAction(self)




    def otherAction(self):

        localctx = expressParser.OtherActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_otherAction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 973
            self.match(expressParser.OTHERWISE)
            self.state = 974
            self.match(expressParser.T__6)
            self.state = 975
            self.stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_paramDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamDef" ):
                listener.enterParamDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamDef" ):
                listener.exitParamDef(self)




    def paramDef(self):

        localctx = expressParser.ParamDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_paramDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)




    def parameter(self):

        localctx = expressParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 979
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_paramRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRef" ):
                listener.enterParamRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRef" ):
                listener.exitParamRef(self)




    def paramRef(self):

        localctx = expressParser.ParamRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_paramRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 981
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrecisionSpecContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self):
            return self.getTypedRuleContext(expressParser.NumberExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_precisionSpec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrecisionSpec" ):
                listener.enterPrecisionSpec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrecisionSpec" ):
                listener.exitPrecisionSpec(self)




    def precisionSpec(self):

        localctx = expressParser.PrecisionSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_precisionSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 983
            self.numberExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcCallStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procRef(self):
            return self.getTypedRuleContext(expressParser.ProcRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_procCallStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcCallStmt" ):
                listener.enterProcCallStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcCallStmt" ):
                listener.exitProcCallStmt(self)




    def procCallStmt(self):

        localctx = expressParser.ProcCallStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_procCallStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 985
            self.procRef()
            self.state = 986
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_procDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcDef" ):
                listener.enterProcDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcDef" ):
                listener.exitProcDef(self)




    def procDef(self):

        localctx = expressParser.ProcDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_procDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 988
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcedureDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procHead(self):
            return self.getTypedRuleContext(expressParser.ProcHeadContext,0)


        def prolog(self):
            return self.getTypedRuleContext(expressParser.PrologContext,0)


        def stmts(self):
            return self.getTypedRuleContext(expressParser.StmtsContext,0)


        def END_PROCEDURE(self):
            return self.getToken(expressParser.END_PROCEDURE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_procedureDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureDecl" ):
                listener.enterProcedureDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureDecl" ):
                listener.exitProcedureDecl(self)




    def procedureDecl(self):

        localctx = expressParser.ProcedureDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_procedureDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 990
            self.procHead()
            self.state = 991
            self.prolog()
            self.state = 992
            self.stmts()
            self.state = 993
            self.match(expressParser.END_PROCEDURE)
            self.state = 994
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCEDURE(self):
            return self.getToken(expressParser.PROCEDURE, 0)

        def procDef(self):
            return self.getTypedRuleContext(expressParser.ProcDefContext,0)


        def varParams(self):
            return self.getTypedRuleContext(expressParser.VarParamsContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_procHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcHead" ):
                listener.enterProcHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcHead" ):
                listener.exitProcHead(self)




    def procHead(self):

        localctx = expressParser.ProcHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_procHead)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 996
            self.match(expressParser.PROCEDURE)
            self.state = 997
            self.procDef()
            self.state = 999
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__0:
                self.state = 998
                self.varParams()


            self.state = 1001
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actualParams(self):
            return self.getTypedRuleContext(expressParser.ActualParamsContext,0)


        def procDef(self):
            return self.getTypedRuleContext(expressParser.ProcDefContext,0)


        def stdProc(self):
            return self.getTypedRuleContext(expressParser.StdProcContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_procRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcRef" ):
                listener.enterProcRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcRef" ):
                listener.exitProcRef(self)




    def procRef(self):

        localctx = expressParser.ProcRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_procRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1005
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.SimpleId]:
                self.state = 1003
                self.procDef()
                pass
            elif token in [expressParser.INSERT, expressParser.REMOVE]:
                self.state = 1004
                self.stdProc()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1007
            self.actualParams()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrologContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(expressParser.DeclarationContext,i)


        def constantDecl(self):
            return self.getTypedRuleContext(expressParser.ConstantDeclContext,0)


        def localDecl(self):
            return self.getTypedRuleContext(expressParser.LocalDeclContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_prolog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProlog" ):
                listener.enterProlog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProlog" ):
                listener.exitProlog(self)




    def prolog(self):

        localctx = expressParser.PrologContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_prolog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1012
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & ((1 << (expressParser.ENTITY - 71)) | (1 << (expressParser.FUNCTION - 71)) | (1 << (expressParser.PROCEDURE - 71)))) != 0) or _la==expressParser.TYPE:
                self.state = 1009
                self.declaration()
                self.state = 1014
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1016
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.CONSTANT:
                self.state = 1015
                self.constantDecl()


            self.state = 1019
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.LOCAL:
                self.state = 1018
                self.localDecl()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PseudoTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregateType(self):
            return self.getTypedRuleContext(expressParser.AggregateTypeContext,0)


        def genericType(self):
            return self.getTypedRuleContext(expressParser.GenericTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_pseudoType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPseudoType" ):
                listener.enterPseudoType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPseudoType" ):
                listener.exitPseudoType(self)




    def pseudoType(self):

        localctx = expressParser.PseudoTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_pseudoType)
        try:
            self.state = 1023
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.AGGREGATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1021
                self.aggregateType()
                pass
            elif token in [expressParser.GENERIC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1022
                self.genericType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subscript(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.SubscriptContext)
            else:
                return self.getTypedRuleContext(expressParser.SubscriptContext,i)


        def attrRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.AttrRefContext)
            else:
                return self.getTypedRuleContext(expressParser.AttrRefContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_qualifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifier" ):
                listener.enterQualifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifier" ):
                listener.exitQualifier(self)




    def qualifier(self):

        localctx = expressParser.QualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_qualifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1030
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__4 or _la==expressParser.T__13:
                self.state = 1028
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [expressParser.T__13]:
                    self.state = 1025
                    self.match(expressParser.T__13)
                    self.state = 1026
                    self.attrRef()
                    pass
                elif token in [expressParser.T__4]:
                    self.state = 1027
                    self.subscript()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1032
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryAssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDef(self):
            return self.getTypedRuleContext(expressParser.VarDefContext,0)


        def aggregateExpr(self):
            return self.getTypedRuleContext(expressParser.AggregateExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_queryAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryAssignment" ):
                listener.enterQueryAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryAssignment" ):
                listener.exitQueryAssignment(self)




    def queryAssignment(self):

        localctx = expressParser.QueryAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_queryAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1033
            self.varDef()
            self.state = 1034
            self.match(expressParser.T__25)
            self.state = 1035
            self.aggregateExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUERY(self):
            return self.getToken(expressParser.QUERY, 0)

        def queryAssignment(self):
            return self.getTypedRuleContext(expressParser.QueryAssignmentContext,0)


        def queryScan(self):
            return self.getTypedRuleContext(expressParser.QueryScanContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_queryExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpr" ):
                listener.enterQueryExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpr" ):
                listener.exitQueryExpr(self)




    def queryExpr(self):

        localctx = expressParser.QueryExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_queryExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1037
            self.match(expressParser.QUERY)
            self.state = 1038
            self.match(expressParser.T__0)
            self.state = 1039
            self.queryAssignment()
            self.state = 1040
            self.match(expressParser.T__26)
            self.state = 1041
            self.queryScan()
            self.state = 1042
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryScanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpr(self):
            return self.getTypedRuleContext(expressParser.LogicalExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_queryScan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryScan" ):
                listener.enterQueryScan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryScan" ):
                listener.exitQueryScan(self)




    def queryScan(self):

        localctx = expressParser.QueryScanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_queryScan)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1044
            self.logicalExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL(self):
            return self.getToken(expressParser.REAL, 0)

        def precisionSpec(self):
            return self.getTypedRuleContext(expressParser.PrecisionSpecContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_realType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealType" ):
                listener.enterRealType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealType" ):
                listener.exitRealType(self)




    def realType(self):

        localctx = expressParser.RealTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_realType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1046
            self.match(expressParser.REAL)
            self.state = 1051
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__0:
                self.state = 1047
                self.match(expressParser.T__0)
                self.state = 1048
                self.precisionSpec()
                self.state = 1049
                self.match(expressParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReferenceClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REFERENCE(self):
            return self.getToken(expressParser.REFERENCE, 0)

        def FROM(self):
            return self.getToken(expressParser.FROM, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(expressParser.SchemaRefContext,0)


        def importList(self):
            return self.getTypedRuleContext(expressParser.ImportListContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_referenceClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferenceClause" ):
                listener.enterReferenceClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferenceClause" ):
                listener.exitReferenceClause(self)




    def referenceClause(self):

        localctx = expressParser.ReferenceClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_referenceClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1053
            self.match(expressParser.REFERENCE)
            self.state = 1054
            self.match(expressParser.FROM)
            self.state = 1055
            self.schemaRef()
            self.state = 1057
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__0:
                self.state = 1056
                self.importList()


            self.state = 1059
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReferencedAttrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrRef(self):
            return self.getTypedRuleContext(expressParser.AttrRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_referencedAttr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferencedAttr" ):
                listener.enterReferencedAttr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferencedAttr" ):
                listener.exitReferencedAttr(self)




    def referencedAttr(self):

        localctx = expressParser.ReferencedAttrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_referencedAttr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1061
            self.attrRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemarkContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def embeddedRemark(self):
            return self.getTypedRuleContext(expressParser.EmbeddedRemarkContext,0)


        def tailRemark(self):
            return self.getTypedRuleContext(expressParser.TailRemarkContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_remark

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemark" ):
                listener.enterRemark(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemark" ):
                listener.exitRemark(self)




    def remark(self):

        localctx = expressParser.RemarkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_remark)
        try:
            self.state = 1065
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.T__11]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1063
                self.embeddedRemark()
                pass
            elif token in [expressParser.T__1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1064
                self.tailRemark()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemarkStuffContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return expressParser.RULE_remarkStuff

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemarkStuff" ):
                listener.enterRemarkStuff(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemarkStuff" ):
                listener.exitRemarkStuff(self)




    def remarkStuff(self):

        localctx = expressParser.RemarkStuffContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_remarkStuff)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1067
            self.matchWildcard()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepeatControlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def incrementControl(self):
            return self.getTypedRuleContext(expressParser.IncrementControlContext,0)


        def whileControl(self):
            return self.getTypedRuleContext(expressParser.WhileControlContext,0)


        def untilControl(self):
            return self.getTypedRuleContext(expressParser.UntilControlContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_repeatControl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepeatControl" ):
                listener.enterRepeatControl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepeatControl" ):
                listener.exitRepeatControl(self)




    def repeatControl(self):

        localctx = expressParser.RepeatControlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_repeatControl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1070
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.SimpleId:
                self.state = 1069
                self.incrementControl()


            self.state = 1073
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.WHILE:
                self.state = 1072
                self.whileControl()


            self.state = 1076
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.UNTIL:
                self.state = 1075
                self.untilControl()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepeateStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPEAT(self):
            return self.getToken(expressParser.REPEAT, 0)

        def repeatControl(self):
            return self.getTypedRuleContext(expressParser.RepeatControlContext,0)


        def stmts(self):
            return self.getTypedRuleContext(expressParser.StmtsContext,0)


        def END_REPEAT(self):
            return self.getToken(expressParser.END_REPEAT, 0)

        def getRuleIndex(self):
            return expressParser.RULE_repeateStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepeateStmt" ):
                listener.enterRepeateStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepeateStmt" ):
                listener.exitRepeateStmt(self)




    def repeateStmt(self):

        localctx = expressParser.RepeateStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_repeateStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1078
            self.match(expressParser.REPEAT)
            self.state = 1079
            self.repeatControl()
            self.state = 1080
            self.match(expressParser.T__7)
            self.state = 1081
            self.stmts()
            self.state = 1082
            self.match(expressParser.END_REPEAT)
            self.state = 1083
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepetitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self):
            return self.getTypedRuleContext(expressParser.NumberExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_repetition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepetition" ):
                listener.enterRepetition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepetition" ):
                listener.exitRepetition(self)




    def repetition(self):

        localctx = expressParser.RepetitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_repetition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1085
            self.numberExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(expressParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def UNKNOWN(self):
            return self.getToken(expressParser.UNKNOWN, 0)

        def getRuleIndex(self):
            return expressParser.RULE_returnStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStmt" ):
                listener.enterReturnStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStmt" ):
                listener.exitReturnStmt(self)




    def returnStmt(self):

        localctx = expressParser.ReturnStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_returnStmt)
        self._la = 0 # Token type
        try:
            self.state = 1102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1087
                self.match(expressParser.RETURN)
                self.state = 1092
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.T__0:
                    self.state = 1088
                    self.match(expressParser.T__0)
                    self.state = 1089
                    self.expression()
                    self.state = 1090
                    self.match(expressParser.T__3)


                self.state = 1094
                self.match(expressParser.T__7)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1095
                self.match(expressParser.RETURN)
                self.state = 1099
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.T__0:
                    self.state = 1096
                    self.match(expressParser.T__0)
                    self.state = 1097
                    self.match(expressParser.UNKNOWN)
                    self.state = 1098
                    self.match(expressParser.T__3)


                self.state = 1101
                self.match(expressParser.T__7)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleHead(self):
            return self.getTypedRuleContext(expressParser.RuleHeadContext,0)


        def prolog(self):
            return self.getTypedRuleContext(expressParser.PrologContext,0)


        def domainRules(self):
            return self.getTypedRuleContext(expressParser.DomainRulesContext,0)


        def END_RULE(self):
            return self.getToken(expressParser.END_RULE, 0)

        def stmts(self):
            return self.getTypedRuleContext(expressParser.StmtsContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_ruleDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDecl" ):
                listener.enterRuleDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDecl" ):
                listener.exitRuleDecl(self)




    def ruleDecl(self):

        localctx = expressParser.RuleDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_ruleDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1104
            self.ruleHead()
            self.state = 1105
            self.prolog()
            self.state = 1107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__7) | (1 << expressParser.T__29) | (1 << expressParser.ABS) | (1 << expressParser.ACOS) | (1 << expressParser.ALIAS) | (1 << expressParser.ASIN) | (1 << expressParser.ATAN) | (1 << expressParser.BEGIN) | (1 << expressParser.BLENGTH) | (1 << expressParser.CASE) | (1 << expressParser.CONST_E) | (1 << expressParser.COS))) != 0) or ((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & ((1 << (expressParser.ESCAPE - 73)) | (1 << (expressParser.EXISTS - 73)) | (1 << (expressParser.EXP - 73)) | (1 << (expressParser.FORMAT - 73)) | (1 << (expressParser.HIBOUND - 73)) | (1 << (expressParser.HIINDEX - 73)) | (1 << (expressParser.IF - 73)) | (1 << (expressParser.INSERT - 73)) | (1 << (expressParser.LENGTH - 73)) | (1 << (expressParser.LOBOUND - 73)) | (1 << (expressParser.LOINDEX - 73)) | (1 << (expressParser.LOG - 73)) | (1 << (expressParser.LOG2 - 73)) | (1 << (expressParser.LOG10 - 73)) | (1 << (expressParser.NVL - 73)) | (1 << (expressParser.ODD - 73)) | (1 << (expressParser.PI - 73)) | (1 << (expressParser.REMOVE - 73)) | (1 << (expressParser.REPEAT - 73)) | (1 << (expressParser.RETURN - 73)) | (1 << (expressParser.ROLESOF - 73)) | (1 << (expressParser.SELF - 73)) | (1 << (expressParser.SIN - 73)) | (1 << (expressParser.SIZEOF - 73)) | (1 << (expressParser.SKIP2 - 73)) | (1 << (expressParser.SQRT - 73)) | (1 << (expressParser.TAN - 73)) | (1 << (expressParser.TYPEOF - 73)))) != 0) or ((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (expressParser.USEDIN - 141)) | (1 << (expressParser.VALUE - 141)) | (1 << (expressParser.SimpleId - 141)) | (1 << (expressParser.Path - 141)))) != 0):
                self.state = 1106
                self.stmts()


            self.state = 1109
            self.domainRules()
            self.state = 1110
            self.match(expressParser.END_RULE)
            self.state = 1111
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_ruleDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDef" ):
                listener.enterRuleDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDef" ):
                listener.exitRuleDef(self)




    def ruleDef(self):

        localctx = expressParser.RuleDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_ruleDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1113
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE(self):
            return self.getToken(expressParser.RULE, 0)

        def ruleDef(self):
            return self.getTypedRuleContext(expressParser.RuleDefContext,0)


        def FOR(self):
            return self.getToken(expressParser.FOR, 0)

        def ruleList(self):
            return self.getTypedRuleContext(expressParser.RuleListContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_ruleHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleHead" ):
                listener.enterRuleHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleHead" ):
                listener.exitRuleHead(self)




    def ruleHead(self):

        localctx = expressParser.RuleHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_ruleHead)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1115
            self.match(expressParser.RULE)
            self.state = 1116
            self.ruleDef()
            self.state = 1117
            self.match(expressParser.FOR)
            self.state = 1118
            self.ruleList()
            self.state = 1119
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.EntityRefContext)
            else:
                return self.getTypedRuleContext(expressParser.EntityRefContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_ruleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleList" ):
                listener.enterRuleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleList" ):
                listener.exitRuleList(self)




    def ruleList(self):

        localctx = expressParser.RuleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_ruleList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121
            self.match(expressParser.T__0)
            self.state = 1122
            self.entityRef()
            self.state = 1127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 1123
                self.match(expressParser.T__2)
                self.state = 1124
                self.entityRef()
                self.state = 1129
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1130
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interfaceSpecification(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.InterfaceSpecificationContext)
            else:
                return self.getTypedRuleContext(expressParser.InterfaceSpecificationContext,i)


        def constantDecl(self):
            return self.getTypedRuleContext(expressParser.ConstantDeclContext,0)


        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(expressParser.DeclarationContext,i)


        def ruleDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.RuleDeclContext)
            else:
                return self.getTypedRuleContext(expressParser.RuleDeclContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_schemaBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaBody" ):
                listener.enterSchemaBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaBody" ):
                listener.exitSchemaBody(self)




    def schemaBody(self):

        localctx = expressParser.SchemaBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_schemaBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.REFERENCE or _la==expressParser.USE:
                self.state = 1132
                self.interfaceSpecification()
                self.state = 1137
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.CONSTANT:
                self.state = 1138
                self.constantDecl()


            self.state = 1145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & ((1 << (expressParser.ENTITY - 71)) | (1 << (expressParser.FUNCTION - 71)) | (1 << (expressParser.PROCEDURE - 71)) | (1 << (expressParser.RULE - 71)))) != 0) or _la==expressParser.TYPE:
                self.state = 1143
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [expressParser.ENTITY, expressParser.FUNCTION, expressParser.PROCEDURE, expressParser.TYPE]:
                    self.state = 1141
                    self.declaration()
                    pass
                elif token in [expressParser.RULE]:
                    self.state = 1142
                    self.ruleDecl()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEMA(self):
            return self.getToken(expressParser.SCHEMA, 0)

        def SchemaDef(self):
            return self.getToken(expressParser.SchemaDef, 0)

        def schemaBody(self):
            return self.getTypedRuleContext(expressParser.SchemaBodyContext,0)


        def END_SCHEMA(self):
            return self.getToken(expressParser.END_SCHEMA, 0)

        def getRuleIndex(self):
            return expressParser.RULE_schemaDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaDecl" ):
                listener.enterSchemaDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaDecl" ):
                listener.exitSchemaDecl(self)




    def schemaDecl(self):

        localctx = expressParser.SchemaDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_schemaDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1148
            self.match(expressParser.SCHEMA)
            self.state = 1149
            self.match(expressParser.SchemaDef)
            self.state = 1150
            self.match(expressParser.T__7)
            self.state = 1151
            self.schemaBody()
            self.state = 1152
            self.match(expressParser.END_SCHEMA)
            self.state = 1153
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_schemaRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaRef" ):
                listener.enterSchemaRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaRef" ):
                listener.exitSchemaRef(self)




    def schemaRef(self):

        localctx = expressParser.SchemaRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_schemaRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_selector

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelector" ):
                listener.enterSelector(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelector" ):
                listener.exitSelector(self)




    def selector(self):

        localctx = expressParser.SelectorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_selector)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1157
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(expressParser.SELECT, 0)

        def selectValues(self):
            return self.getTypedRuleContext(expressParser.SelectValuesContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_selectType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectType" ):
                listener.enterSelectType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectType" ):
                listener.exitSelectType(self)




    def selectType(self):

        localctx = expressParser.SelectTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_selectType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1159
            self.match(expressParser.SELECT)
            self.state = 1160
            self.match(expressParser.T__0)
            self.state = 1161
            self.selectValues()
            self.state = 1162
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectValuesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.NamedTypeContext)
            else:
                return self.getTypedRuleContext(expressParser.NamedTypeContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_selectValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectValues" ):
                listener.enterSelectValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectValues" ):
                listener.exitSelectValues(self)




    def selectValues(self):

        localctx = expressParser.SelectValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_selectValues)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1164
            self.namedType()
            self.state = 1169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 1165
                self.match(expressParser.T__2)
                self.state = 1166
                self.namedType()
                self.state = 1171
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(expressParser.SET, 0)

        def boundSpec(self):
            return self.getTypedRuleContext(expressParser.BoundSpecContext,0)


        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def collectionTypeSel(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeSelContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_setType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetType" ):
                listener.enterSetType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetType" ):
                listener.exitSetType(self)




    def setType(self):

        localctx = expressParser.SetTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_setType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1172
            self.match(expressParser.SET)
            self.state = 1173
            self.boundSpec()
            self.state = 1174
            self.match(expressParser.OF)
            self.state = 1175
            self.collectionTypeSel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.TermContext)
            else:
                return self.getTypedRuleContext(expressParser.TermContext,i)


        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.OR)
            else:
                return self.getToken(expressParser.OR, i)

        def XOR(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.XOR)
            else:
                return self.getToken(expressParser.XOR, i)

        def getRuleIndex(self):
            return expressParser.RULE_simpleExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr" ):
                listener.enterSimpleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr" ):
                listener.exitSimpleExpr(self)




    def simpleExpr(self):

        localctx = expressParser.SimpleExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_simpleExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1177
            self.term()
            self.state = 1182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__27 or _la==expressParser.T__28 or _la==expressParser.OR or _la==expressParser.XOR:
                self.state = 1178
                _la = self._input.LA(1)
                if not(_la==expressParser.T__27 or _la==expressParser.T__28 or _la==expressParser.OR or _la==expressParser.XOR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1179
                self.term()
                self.state = 1184
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleFactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Path(self):
            return self.getToken(expressParser.Path, 0)

        def literal(self):
            return self.getTypedRuleContext(expressParser.LiteralContext,0)


        def varRef(self):
            return self.getTypedRuleContext(expressParser.VarRefContext,0)


        def interval(self):
            return self.getTypedRuleContext(expressParser.IntervalContext,0)


        def queryExpr(self):
            return self.getTypedRuleContext(expressParser.QueryExprContext,0)


        def expression(self):
            return self.getTypedRuleContext(expressParser.ExpressionContext,0)


        def unaryOp(self):
            return self.getTypedRuleContext(expressParser.UnaryOpContext,0)


        def simpleFactor(self):
            return self.getTypedRuleContext(expressParser.SimpleFactorContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_simpleFactor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleFactor" ):
                listener.enterSimpleFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleFactor" ):
                listener.exitSimpleFactor(self)




    def simpleFactor(self):

        localctx = expressParser.SimpleFactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_simpleFactor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.state = 1185
                self.match(expressParser.Path)
                pass

            elif la_ == 2:
                self.state = 1186
                self.literal()
                pass

            elif la_ == 3:
                self.state = 1187
                self.varRef()
                pass

            elif la_ == 4:
                self.state = 1188
                self.interval()
                pass

            elif la_ == 5:
                self.state = 1189
                self.queryExpr()
                pass

            elif la_ == 6:
                self.state = 1190
                self.match(expressParser.T__0)
                self.state = 1191
                self.expression()
                self.state = 1192
                self.match(expressParser.T__3)
                pass

            elif la_ == 7:
                self.state = 1194
                self.unaryOp()
                self.state = 1195
                self.simpleFactor()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binaryType(self):
            return self.getTypedRuleContext(expressParser.BinaryTypeContext,0)


        def booleanType(self):
            return self.getTypedRuleContext(expressParser.BooleanTypeContext,0)


        def integerType(self):
            return self.getTypedRuleContext(expressParser.IntegerTypeContext,0)


        def logicalType(self):
            return self.getTypedRuleContext(expressParser.LogicalTypeContext,0)


        def numberType(self):
            return self.getTypedRuleContext(expressParser.NumberTypeContext,0)


        def realType(self):
            return self.getTypedRuleContext(expressParser.RealTypeContext,0)


        def stringType(self):
            return self.getTypedRuleContext(expressParser.StringTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_simpleType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleType" ):
                listener.enterSimpleType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleType" ):
                listener.exitSimpleType(self)




    def simpleType(self):

        localctx = expressParser.SimpleTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_simpleType)
        try:
            self.state = 1206
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.BINARY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1199
                self.binaryType()
                pass
            elif token in [expressParser.BOOLEAN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1200
                self.booleanType()
                pass
            elif token in [expressParser.INTEGER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1201
                self.integerType()
                pass
            elif token in [expressParser.LOGICAL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1202
                self.logicalType()
                pass
            elif token in [expressParser.NUMBER]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1203
                self.numberType()
                pass
            elif token in [expressParser.REAL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1204
                self.realType()
                pass
            elif token in [expressParser.STRING]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1205
                self.stringType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkipStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKIP2(self):
            return self.getToken(expressParser.SKIP2, 0)

        def getRuleIndex(self):
            return expressParser.RULE_skipStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkipStmt" ):
                listener.enterSkipStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkipStmt" ):
                listener.exitSkipStmt(self)




    def skipStmt(self):

        localctx = expressParser.SkipStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_skipStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1208
            self.match(expressParser.SKIP2)
            self.state = 1209
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StdConstContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONST_E(self):
            return self.getToken(expressParser.CONST_E, 0)

        def PI(self):
            return self.getToken(expressParser.PI, 0)

        def SELF(self):
            return self.getToken(expressParser.SELF, 0)

        def getRuleIndex(self):
            return expressParser.RULE_stdConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStdConst" ):
                listener.enterStdConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStdConst" ):
                listener.exitStdConst(self)




    def stdConst(self):

        localctx = expressParser.StdConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_stdConst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1211
            _la = self._input.LA(1)
            if not(_la==expressParser.T__29 or _la==expressParser.CONST_E or _la==expressParser.PI or _la==expressParser.SELF):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StdFuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABS(self):
            return self.getToken(expressParser.ABS, 0)

        def ACOS(self):
            return self.getToken(expressParser.ACOS, 0)

        def ASIN(self):
            return self.getToken(expressParser.ASIN, 0)

        def ATAN(self):
            return self.getToken(expressParser.ATAN, 0)

        def BLENGTH(self):
            return self.getToken(expressParser.BLENGTH, 0)

        def COS(self):
            return self.getToken(expressParser.COS, 0)

        def EXISTS(self):
            return self.getToken(expressParser.EXISTS, 0)

        def EXP(self):
            return self.getToken(expressParser.EXP, 0)

        def FORMAT(self):
            return self.getToken(expressParser.FORMAT, 0)

        def HIBOUND(self):
            return self.getToken(expressParser.HIBOUND, 0)

        def HIINDEX(self):
            return self.getToken(expressParser.HIINDEX, 0)

        def LENGTH(self):
            return self.getToken(expressParser.LENGTH, 0)

        def LOBOUND(self):
            return self.getToken(expressParser.LOBOUND, 0)

        def LOINDEX(self):
            return self.getToken(expressParser.LOINDEX, 0)

        def LOG(self):
            return self.getToken(expressParser.LOG, 0)

        def LOG2(self):
            return self.getToken(expressParser.LOG2, 0)

        def LOG10(self):
            return self.getToken(expressParser.LOG10, 0)

        def NVL(self):
            return self.getToken(expressParser.NVL, 0)

        def ODD(self):
            return self.getToken(expressParser.ODD, 0)

        def ROLESOF(self):
            return self.getToken(expressParser.ROLESOF, 0)

        def SIN(self):
            return self.getToken(expressParser.SIN, 0)

        def SIZEOF(self):
            return self.getToken(expressParser.SIZEOF, 0)

        def SQRT(self):
            return self.getToken(expressParser.SQRT, 0)

        def TAN(self):
            return self.getToken(expressParser.TAN, 0)

        def TYPEOF(self):
            return self.getToken(expressParser.TYPEOF, 0)

        def USEDIN(self):
            return self.getToken(expressParser.USEDIN, 0)

        def VALUE(self):
            return self.getToken(expressParser.VALUE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_stdFunc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStdFunc" ):
                listener.enterStdFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStdFunc" ):
                listener.exitStdFunc(self)




    def stdFunc(self):

        localctx = expressParser.StdFuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_stdFunc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1213
            _la = self._input.LA(1)
            if not(((((_la - 34)) & ~0x3f) == 0 and ((1 << (_la - 34)) & ((1 << (expressParser.ABS - 34)) | (1 << (expressParser.ACOS - 34)) | (1 << (expressParser.ASIN - 34)) | (1 << (expressParser.ATAN - 34)) | (1 << (expressParser.BLENGTH - 34)) | (1 << (expressParser.COS - 34)) | (1 << (expressParser.EXISTS - 34)) | (1 << (expressParser.EXP - 34)) | (1 << (expressParser.FORMAT - 34)) | (1 << (expressParser.HIBOUND - 34)) | (1 << (expressParser.HIINDEX - 34)) | (1 << (expressParser.LENGTH - 34)) | (1 << (expressParser.LOBOUND - 34)) | (1 << (expressParser.LOINDEX - 34)) | (1 << (expressParser.LOG - 34)))) != 0) or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (expressParser.LOG2 - 98)) | (1 << (expressParser.LOG10 - 98)) | (1 << (expressParser.NVL - 98)) | (1 << (expressParser.ODD - 98)) | (1 << (expressParser.ROLESOF - 98)) | (1 << (expressParser.SIN - 98)) | (1 << (expressParser.SIZEOF - 98)) | (1 << (expressParser.SQRT - 98)) | (1 << (expressParser.TAN - 98)) | (1 << (expressParser.TYPEOF - 98)) | (1 << (expressParser.USEDIN - 98)) | (1 << (expressParser.VALUE - 98)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StdProcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT(self):
            return self.getToken(expressParser.INSERT, 0)

        def REMOVE(self):
            return self.getToken(expressParser.REMOVE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_stdProc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStdProc" ):
                listener.enterStdProc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStdProc" ):
                listener.exitStdProc(self)




    def stdProc(self):

        localctx = expressParser.StdProcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_stdProc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1215
            _la = self._input.LA(1)
            if not(_la==expressParser.INSERT or _la==expressParser.REMOVE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasStmt(self):
            return self.getTypedRuleContext(expressParser.AliasStmtContext,0)


        def assignmentStmt(self):
            return self.getTypedRuleContext(expressParser.AssignmentStmtContext,0)


        def caseStmt(self):
            return self.getTypedRuleContext(expressParser.CaseStmtContext,0)


        def compoundStmt(self):
            return self.getTypedRuleContext(expressParser.CompoundStmtContext,0)


        def escapeStmt(self):
            return self.getTypedRuleContext(expressParser.EscapeStmtContext,0)


        def ifStmt(self):
            return self.getTypedRuleContext(expressParser.IfStmtContext,0)


        def nullStmt(self):
            return self.getTypedRuleContext(expressParser.NullStmtContext,0)


        def procCallStmt(self):
            return self.getTypedRuleContext(expressParser.ProcCallStmtContext,0)


        def repeateStmt(self):
            return self.getTypedRuleContext(expressParser.RepeateStmtContext,0)


        def returnStmt(self):
            return self.getTypedRuleContext(expressParser.ReturnStmtContext,0)


        def skipStmt(self):
            return self.getTypedRuleContext(expressParser.SkipStmtContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)




    def stmt(self):

        localctx = expressParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_stmt)
        try:
            self.state = 1228
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1217
                self.aliasStmt()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1218
                self.assignmentStmt()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1219
                self.caseStmt()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1220
                self.compoundStmt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1221
                self.escapeStmt()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1222
                self.ifStmt()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1223
                self.nullStmt()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1224
                self.procCallStmt()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1225
                self.repeateStmt()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1226
                self.returnStmt()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1227
                self.skipStmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StmtsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.StmtContext)
            else:
                return self.getTypedRuleContext(expressParser.StmtContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_stmts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmts" ):
                listener.enterStmts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmts" ):
                listener.exitStmts(self)




    def stmts(self):

        localctx = expressParser.StmtsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_stmts)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1230
            self.stmt()
            self.state = 1234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__7) | (1 << expressParser.T__29) | (1 << expressParser.ABS) | (1 << expressParser.ACOS) | (1 << expressParser.ALIAS) | (1 << expressParser.ASIN) | (1 << expressParser.ATAN) | (1 << expressParser.BEGIN) | (1 << expressParser.BLENGTH) | (1 << expressParser.CASE) | (1 << expressParser.CONST_E) | (1 << expressParser.COS))) != 0) or ((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & ((1 << (expressParser.ESCAPE - 73)) | (1 << (expressParser.EXISTS - 73)) | (1 << (expressParser.EXP - 73)) | (1 << (expressParser.FORMAT - 73)) | (1 << (expressParser.HIBOUND - 73)) | (1 << (expressParser.HIINDEX - 73)) | (1 << (expressParser.IF - 73)) | (1 << (expressParser.INSERT - 73)) | (1 << (expressParser.LENGTH - 73)) | (1 << (expressParser.LOBOUND - 73)) | (1 << (expressParser.LOINDEX - 73)) | (1 << (expressParser.LOG - 73)) | (1 << (expressParser.LOG2 - 73)) | (1 << (expressParser.LOG10 - 73)) | (1 << (expressParser.NVL - 73)) | (1 << (expressParser.ODD - 73)) | (1 << (expressParser.PI - 73)) | (1 << (expressParser.REMOVE - 73)) | (1 << (expressParser.REPEAT - 73)) | (1 << (expressParser.RETURN - 73)) | (1 << (expressParser.ROLESOF - 73)) | (1 << (expressParser.SELF - 73)) | (1 << (expressParser.SIN - 73)) | (1 << (expressParser.SIZEOF - 73)) | (1 << (expressParser.SKIP2 - 73)) | (1 << (expressParser.SQRT - 73)) | (1 << (expressParser.TAN - 73)) | (1 << (expressParser.TYPEOF - 73)))) != 0) or ((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (expressParser.USEDIN - 141)) | (1 << (expressParser.VALUE - 141)) | (1 << (expressParser.SimpleId - 141)) | (1 << (expressParser.Path - 141)))) != 0):
                self.state = 1231
                self.stmt()
                self.state = 1236
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(expressParser.STRING, 0)

        def width(self):
            return self.getTypedRuleContext(expressParser.WidthContext,0)


        def FIXED(self):
            return self.getToken(expressParser.FIXED, 0)

        def getRuleIndex(self):
            return expressParser.RULE_stringType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringType" ):
                listener.enterStringType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringType" ):
                listener.exitStringType(self)




    def stringType(self):

        localctx = expressParser.StringTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_stringType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1237
            self.match(expressParser.STRING)
            self.state = 1244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__0:
                self.state = 1238
                self.match(expressParser.T__0)
                self.state = 1239
                self.width()
                self.state = 1240
                self.match(expressParser.T__3)
                self.state = 1242
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.FIXED:
                    self.state = 1241
                    self.match(expressParser.FIXED)




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubSuperContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def supertypeDecl(self):
            return self.getTypedRuleContext(expressParser.SupertypeDeclContext,0)


        def subtypeDecl(self):
            return self.getTypedRuleContext(expressParser.SubtypeDeclContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_subSuper

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubSuper" ):
                listener.enterSubSuper(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubSuper" ):
                listener.exitSubSuper(self)




    def subSuper(self):

        localctx = expressParser.SubSuperContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_subSuper)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.ABSTRACT or _la==expressParser.SUPERTYPE:
                self.state = 1246
                self.supertypeDecl()


            self.state = 1250
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.SUBTYPE:
                self.state = 1249
                self.subtypeDecl()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubscriptContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.NumberExprContext)
            else:
                return self.getTypedRuleContext(expressParser.NumberExprContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_subscript

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubscript" ):
                listener.enterSubscript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubscript" ):
                listener.exitSubscript(self)




    def subscript(self):

        localctx = expressParser.SubscriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_subscript)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                self.state = 1252
                self.match(expressParser.T__4)
                self.state = 1253
                self.numberExpr()
                self.state = 1254
                self.match(expressParser.T__5)
                pass

            elif la_ == 2:
                self.state = 1256
                self.match(expressParser.T__4)
                self.state = 1257
                self.numberExpr()
                self.state = 1258
                self.match(expressParser.T__6)
                self.state = 1259
                self.numberExpr()
                self.state = 1260
                self.match(expressParser.T__5)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubtypeDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBTYPE(self):
            return self.getToken(expressParser.SUBTYPE, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def entityRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.EntityRefContext)
            else:
                return self.getTypedRuleContext(expressParser.EntityRefContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_subtypeDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubtypeDecl" ):
                listener.enterSubtypeDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubtypeDecl" ):
                listener.exitSubtypeDecl(self)




    def subtypeDecl(self):

        localctx = expressParser.SubtypeDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_subtypeDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1264
            self.match(expressParser.SUBTYPE)
            self.state = 1265
            self.match(expressParser.OF)
            self.state = 1266
            self.match(expressParser.T__0)
            self.state = 1267
            self.entityRef()
            self.state = 1272
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 1268
                self.match(expressParser.T__2)
                self.state = 1269
                self.entityRef()
                self.state = 1274
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1275
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupertypeDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABSTRACT(self):
            return self.getToken(expressParser.ABSTRACT, 0)

        def SUPERTYPE(self):
            return self.getToken(expressParser.SUPERTYPE, 0)

        def OF(self):
            return self.getToken(expressParser.OF, 0)

        def supertypeExpr(self):
            return self.getTypedRuleContext(expressParser.SupertypeExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_supertypeDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupertypeDecl" ):
                listener.enterSupertypeDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupertypeDecl" ):
                listener.exitSupertypeDecl(self)




    def supertypeDecl(self):

        localctx = expressParser.SupertypeDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_supertypeDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1288
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 1277
                self.match(expressParser.ABSTRACT)
                self.state = 1278
                self.match(expressParser.SUPERTYPE)
                pass

            elif la_ == 2:
                self.state = 1280
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==expressParser.ABSTRACT:
                    self.state = 1279
                    self.match(expressParser.ABSTRACT)


                self.state = 1282
                self.match(expressParser.SUPERTYPE)
                self.state = 1283
                self.match(expressParser.OF)
                self.state = 1284
                self.match(expressParser.T__0)
                self.state = 1285
                self.supertypeExpr()
                self.state = 1286
                self.match(expressParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupertypeExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def supertypeFactor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.SupertypeFactorContext)
            else:
                return self.getTypedRuleContext(expressParser.SupertypeFactorContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.AND)
            else:
                return self.getToken(expressParser.AND, i)

        def ANDOR(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.ANDOR)
            else:
                return self.getToken(expressParser.ANDOR, i)

        def getRuleIndex(self):
            return expressParser.RULE_supertypeExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupertypeExpr" ):
                listener.enterSupertypeExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupertypeExpr" ):
                listener.exitSupertypeExpr(self)




    def supertypeExpr(self):

        localctx = expressParser.SupertypeExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_supertypeExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1290
            self.supertypeFactor()
            self.state = 1295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.AND or _la==expressParser.ANDOR:
                self.state = 1291
                _la = self._input.LA(1)
                if not(_la==expressParser.AND or _la==expressParser.ANDOR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1292
                self.supertypeFactor()
                self.state = 1297
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupertypeFactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def choice(self):
            return self.getTypedRuleContext(expressParser.ChoiceContext,0)


        def supertypeExpr(self):
            return self.getTypedRuleContext(expressParser.SupertypeExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_supertypeFactor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupertypeFactor" ):
                listener.enterSupertypeFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupertypeFactor" ):
                listener.exitSupertypeFactor(self)




    def supertypeFactor(self):

        localctx = expressParser.SupertypeFactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_supertypeFactor)
        try:
            self.state = 1304
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.SimpleId]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1298
                self.entityRef()
                pass
            elif token in [expressParser.ONEOF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1299
                self.choice()
                pass
            elif token in [expressParser.T__0]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1300
                self.match(expressParser.T__0)
                self.state = 1301
                self.supertypeExpr()
                self.state = 1302
                self.match(expressParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TailRemarkContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def remarkStuff(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.RemarkStuffContext)
            else:
                return self.getTypedRuleContext(expressParser.RemarkStuffContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_tailRemark

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTailRemark" ):
                listener.enterTailRemark(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTailRemark" ):
                listener.exitTailRemark(self)




    def tailRemark(self):

        localctx = expressParser.TailRemarkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_tailRemark)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1306
            self.match(expressParser.T__1)
            self.state = 1310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__0) | (1 << expressParser.T__1) | (1 << expressParser.T__2) | (1 << expressParser.T__3) | (1 << expressParser.T__4) | (1 << expressParser.T__5) | (1 << expressParser.T__6) | (1 << expressParser.T__7) | (1 << expressParser.T__8) | (1 << expressParser.T__9) | (1 << expressParser.T__10) | (1 << expressParser.T__11) | (1 << expressParser.T__12) | (1 << expressParser.T__13) | (1 << expressParser.T__14) | (1 << expressParser.T__15) | (1 << expressParser.T__16) | (1 << expressParser.T__17) | (1 << expressParser.T__18) | (1 << expressParser.T__19) | (1 << expressParser.T__20) | (1 << expressParser.T__21) | (1 << expressParser.T__22) | (1 << expressParser.T__23) | (1 << expressParser.T__24) | (1 << expressParser.T__25) | (1 << expressParser.T__26) | (1 << expressParser.T__27) | (1 << expressParser.T__28) | (1 << expressParser.T__29) | (1 << expressParser.T__30) | (1 << expressParser.T__31) | (1 << expressParser.T__32) | (1 << expressParser.ABS) | (1 << expressParser.ABSTRACT) | (1 << expressParser.ACOS) | (1 << expressParser.AGGREGATE) | (1 << expressParser.ALIAS) | (1 << expressParser.AND) | (1 << expressParser.ANDOR) | (1 << expressParser.ARRAY) | (1 << expressParser.AS) | (1 << expressParser.ASIN) | (1 << expressParser.ATAN) | (1 << expressParser.BAG) | (1 << expressParser.BEGIN) | (1 << expressParser.BINARY) | (1 << expressParser.BLENGTH) | (1 << expressParser.BOOLEAN) | (1 << expressParser.BY) | (1 << expressParser.CASE) | (1 << expressParser.CONSTANT) | (1 << expressParser.CONST_E) | (1 << expressParser.COS) | (1 << expressParser.DERIVE) | (1 << expressParser.DIV) | (1 << expressParser.ELSE) | (1 << expressParser.END) | (1 << expressParser.END_ALIAS) | (1 << expressParser.END_CASE) | (1 << expressParser.END_CONSTANT) | (1 << expressParser.END_ENTITY) | (1 << expressParser.END_FUNCTION))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (expressParser.END_IF - 64)) | (1 << (expressParser.END_LOCAL - 64)) | (1 << (expressParser.END_PROCEDURE - 64)) | (1 << (expressParser.END_RULE - 64)) | (1 << (expressParser.END_REPEAT - 64)) | (1 << (expressParser.END_SCHEMA - 64)) | (1 << (expressParser.END_TYPE - 64)) | (1 << (expressParser.ENTITY - 64)) | (1 << (expressParser.ENUMERATION - 64)) | (1 << (expressParser.ESCAPE - 64)) | (1 << (expressParser.EXISTS - 64)) | (1 << (expressParser.EXP - 64)) | (1 << (expressParser.FALSE - 64)) | (1 << (expressParser.FIXED - 64)) | (1 << (expressParser.FOR - 64)) | (1 << (expressParser.FORMAT - 64)) | (1 << (expressParser.FROM - 64)) | (1 << (expressParser.FUNCTION - 64)) | (1 << (expressParser.GENERIC - 64)) | (1 << (expressParser.HIBOUND - 64)) | (1 << (expressParser.HIINDEX - 64)) | (1 << (expressParser.IF - 64)) | (1 << (expressParser.IN - 64)) | (1 << (expressParser.INSERT - 64)) | (1 << (expressParser.INVERSE - 64)) | (1 << (expressParser.INTEGER - 64)) | (1 << (expressParser.LENGTH - 64)) | (1 << (expressParser.LIKE - 64)) | (1 << (expressParser.LIST - 64)) | (1 << (expressParser.LOCAL - 64)) | (1 << (expressParser.LOGICAL - 64)) | (1 << (expressParser.LOBOUND - 64)) | (1 << (expressParser.LOINDEX - 64)) | (1 << (expressParser.LOG - 64)) | (1 << (expressParser.LOG2 - 64)) | (1 << (expressParser.LOG10 - 64)) | (1 << (expressParser.MOD - 64)) | (1 << (expressParser.NOT - 64)) | (1 << (expressParser.NUMBER - 64)) | (1 << (expressParser.NVL - 64)) | (1 << (expressParser.ODD - 64)) | (1 << (expressParser.OF - 64)) | (1 << (expressParser.ONEOF - 64)) | (1 << (expressParser.OPTIONAL - 64)) | (1 << (expressParser.OR - 64)) | (1 << (expressParser.OTHERWISE - 64)) | (1 << (expressParser.PI - 64)) | (1 << (expressParser.PROCEDURE - 64)) | (1 << (expressParser.QUERY - 64)) | (1 << (expressParser.REAL - 64)) | (1 << (expressParser.REFERENCE - 64)) | (1 << (expressParser.REMOVE - 64)) | (1 << (expressParser.REPEAT - 64)) | (1 << (expressParser.RETURN - 64)) | (1 << (expressParser.ROLESOF - 64)) | (1 << (expressParser.RULE - 64)) | (1 << (expressParser.SCHEMA - 64)) | (1 << (expressParser.SELECT - 64)) | (1 << (expressParser.SELF - 64)) | (1 << (expressParser.SET - 64)) | (1 << (expressParser.SIN - 64)) | (1 << (expressParser.SIZEOF - 64)) | (1 << (expressParser.SKIP2 - 64)) | (1 << (expressParser.SQRT - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (expressParser.STRING - 128)) | (1 << (expressParser.SUBTYPE - 128)) | (1 << (expressParser.SUPERTYPE - 128)) | (1 << (expressParser.TAN - 128)) | (1 << (expressParser.THEN - 128)) | (1 << (expressParser.TO - 128)) | (1 << (expressParser.TRUE - 128)) | (1 << (expressParser.TYPE - 128)) | (1 << (expressParser.TYPEOF - 128)) | (1 << (expressParser.UNIQUE - 128)) | (1 << (expressParser.UNKNOWN - 128)) | (1 << (expressParser.UNTIL - 128)) | (1 << (expressParser.USE - 128)) | (1 << (expressParser.USEDIN - 128)) | (1 << (expressParser.VALUE - 128)) | (1 << (expressParser.VAR - 128)) | (1 << (expressParser.WHERE - 128)) | (1 << (expressParser.WHILE - 128)) | (1 << (expressParser.XOR - 128)) | (1 << (expressParser.SchemaDef - 128)) | (1 << (expressParser.SimpleId - 128)) | (1 << (expressParser.Path - 128)) | (1 << (expressParser.IntegerLiteral - 128)) | (1 << (expressParser.BinaryLiteral - 128)) | (1 << (expressParser.LogicalLiteral - 128)) | (1 << (expressParser.RealLiteral - 128)) | (1 << (expressParser.Digits - 128)) | (1 << (expressParser.Letter - 128)) | (1 << (expressParser.Character - 128)) | (1 << (expressParser.QuoteChar - 128)) | (1 << (expressParser.StringLiteral - 128)) | (1 << (expressParser.NewlineChar - 128)) | (1 << (expressParser.WS - 128)) | (1 << (expressParser.Comments - 128)))) != 0):
                self.state = 1307
                self.remarkStuff()
                self.state = 1312
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.FactorContext)
            else:
                return self.getTypedRuleContext(expressParser.FactorContext,i)


        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.DIV)
            else:
                return self.getToken(expressParser.DIV, i)

        def MOD(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.MOD)
            else:
                return self.getToken(expressParser.MOD, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(expressParser.AND)
            else:
                return self.getToken(expressParser.AND, i)

        def TRUE(self):
            return self.getToken(expressParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(expressParser.FALSE, 0)

        def Path(self):
            return self.getToken(expressParser.Path, 0)

        def arrayType(self):
            return self.getTypedRuleContext(expressParser.ArrayTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = expressParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.state = 1325
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1313
                self.factor()
                self.state = 1318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__30) | (1 << expressParser.T__31) | (1 << expressParser.T__32) | (1 << expressParser.AND) | (1 << expressParser.DIV))) != 0) or _la==expressParser.MOD:
                    self.state = 1314
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << expressParser.T__30) | (1 << expressParser.T__31) | (1 << expressParser.T__32) | (1 << expressParser.AND) | (1 << expressParser.DIV))) != 0) or _la==expressParser.MOD):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1315
                    self.factor()
                    self.state = 1320
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1321
                self.match(expressParser.TRUE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1322
                self.match(expressParser.FALSE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1323
                self.match(expressParser.Path)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1324
                self.arrayType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeDef(self):
            return self.getTypedRuleContext(expressParser.TypeDefContext,0)


        def typeSel(self):
            return self.getTypedRuleContext(expressParser.TypeSelContext,0)


        def domainRules(self):
            return self.getTypedRuleContext(expressParser.DomainRulesContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_typeBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeBody" ):
                listener.enterTypeBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeBody" ):
                listener.exitTypeBody(self)




    def typeBody(self):

        localctx = expressParser.TypeBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_typeBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1327
            self.typeDef()
            self.state = 1328
            self.match(expressParser.T__19)
            self.state = 1329
            self.typeSel()
            self.state = 1330
            self.match(expressParser.T__7)
            self.state = 1332
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.WHERE:
                self.state = 1331
                self.domainRules()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(expressParser.TYPE, 0)

        def typeBody(self):
            return self.getTypedRuleContext(expressParser.TypeBodyContext,0)


        def END_TYPE(self):
            return self.getToken(expressParser.END_TYPE, 0)

        def getRuleIndex(self):
            return expressParser.RULE_typeDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDecl" ):
                listener.enterTypeDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDecl" ):
                listener.exitTypeDecl(self)




    def typeDecl(self):

        localctx = expressParser.TypeDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_typeDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1334
            self.match(expressParser.TYPE)
            self.state = 1335
            self.typeBody()
            self.state = 1336
            self.match(expressParser.END_TYPE)
            self.state = 1337
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_typeDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDef" ):
                listener.enterTypeDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDef" ):
                listener.exitTypeDef(self)




    def typeDef(self):

        localctx = expressParser.TypeDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_typeDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1339
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeLabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_typeLabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeLabel" ):
                listener.enterTypeLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeLabel" ):
                listener.exitTypeLabel(self)




    def typeLabel(self):

        localctx = expressParser.TypeLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_typeLabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1341
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_typeRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeRef" ):
                listener.enterTypeRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeRef" ):
                listener.exitTypeRef(self)




    def typeRef(self):

        localctx = expressParser.TypeRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_typeRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1343
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def collectionType(self):
            return self.getTypedRuleContext(expressParser.CollectionTypeContext,0)


        def namedType(self):
            return self.getTypedRuleContext(expressParser.NamedTypeContext,0)


        def simpleType(self):
            return self.getTypedRuleContext(expressParser.SimpleTypeContext,0)


        def enumType(self):
            return self.getTypedRuleContext(expressParser.EnumTypeContext,0)


        def selectType(self):
            return self.getTypedRuleContext(expressParser.SelectTypeContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_typeSel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSel" ):
                listener.enterTypeSel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSel" ):
                listener.exitTypeSel(self)




    def typeSel(self):

        localctx = expressParser.TypeSelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_typeSel)
        try:
            self.state = 1350
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [expressParser.ARRAY, expressParser.BAG, expressParser.LIST, expressParser.SET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1345
                self.collectionType()
                pass
            elif token in [expressParser.SimpleId]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1346
                self.namedType()
                pass
            elif token in [expressParser.BINARY, expressParser.BOOLEAN, expressParser.INTEGER, expressParser.LOGICAL, expressParser.NUMBER, expressParser.REAL, expressParser.STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1347
                self.simpleType()
                pass
            elif token in [expressParser.ENUMERATION]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1348
                self.enumType()
                pass
            elif token in [expressParser.SELECT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1349
                self.selectType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryOpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(expressParser.NOT, 0)

        def getRuleIndex(self):
            return expressParser.RULE_unaryOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryOp" ):
                listener.enterUnaryOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryOp" ):
                listener.exitUnaryOp(self)




    def unaryOp(self):

        localctx = expressParser.UnaryOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_unaryOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1352
            _la = self._input.LA(1)
            if not(_la==expressParser.T__27 or _la==expressParser.T__28 or _la==expressParser.NOT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniqueRuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelDef(self):
            return self.getTypedRuleContext(expressParser.LabelDefContext,0)


        def referencedAttr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ReferencedAttrContext)
            else:
                return self.getTypedRuleContext(expressParser.ReferencedAttrContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_uniqueRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniqueRule" ):
                listener.enterUniqueRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniqueRule" ):
                listener.exitUniqueRule(self)




    def uniqueRule(self):

        localctx = expressParser.UniqueRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_uniqueRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1354
            self.labelDef()
            self.state = 1355
            self.match(expressParser.T__6)
            self.state = 1356
            self.referencedAttr()
            self.state = 1361
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 1357
                self.match(expressParser.T__2)
                self.state = 1358
                self.referencedAttr()
                self.state = 1363
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniqueRulesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIQUE(self):
            return self.getToken(expressParser.UNIQUE, 0)

        def uniqueRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.UniqueRuleContext)
            else:
                return self.getTypedRuleContext(expressParser.UniqueRuleContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_uniqueRules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniqueRules" ):
                listener.enterUniqueRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniqueRules" ):
                listener.exitUniqueRules(self)




    def uniqueRules(self):

        localctx = expressParser.UniqueRulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_uniqueRules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1364
            self.match(expressParser.UNIQUE)
            self.state = 1365
            self.uniqueRule()
            self.state = 1366
            self.match(expressParser.T__7)
            self.state = 1372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.SimpleId:
                self.state = 1367
                self.uniqueRule()
                self.state = 1368
                self.match(expressParser.T__7)
                self.state = 1374
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UntilControlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNTIL(self):
            return self.getToken(expressParser.UNTIL, 0)

        def logicalExpr(self):
            return self.getTypedRuleContext(expressParser.LogicalExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_untilControl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUntilControl" ):
                listener.enterUntilControl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUntilControl" ):
                listener.exitUntilControl(self)




    def untilControl(self):

        localctx = expressParser.UntilControlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_untilControl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1375
            self.match(expressParser.UNTIL)
            self.state = 1376
            self.logicalExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(expressParser.USE, 0)

        def FROM(self):
            return self.getToken(expressParser.FROM, 0)

        def schemaRef(self):
            return self.getTypedRuleContext(expressParser.SchemaRefContext,0)


        def useList(self):
            return self.getTypedRuleContext(expressParser.UseListContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_useClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseClause" ):
                listener.enterUseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseClause" ):
                listener.exitUseClause(self)




    def useClause(self):

        localctx = expressParser.UseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_useClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1378
            self.match(expressParser.USE)
            self.state = 1379
            self.match(expressParser.FROM)
            self.state = 1380
            self.schemaRef()
            self.state = 1382
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==expressParser.T__0:
                self.state = 1381
                self.useList()


            self.state = 1384
            self.match(expressParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importEntity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.ImportEntityContext)
            else:
                return self.getTypedRuleContext(expressParser.ImportEntityContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_useList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseList" ):
                listener.enterUseList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseList" ):
                listener.exitUseList(self)




    def useList(self):

        localctx = expressParser.UseListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_useList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1386
            self.match(expressParser.T__0)
            self.state = 1387
            self.importEntity()
            self.state = 1392
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__2:
                self.state = 1388
                self.match(expressParser.T__2)
                self.state = 1389
                self.importEntity()
                self.state = 1394
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1395
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SimpleId(self):
            return self.getToken(expressParser.SimpleId, 0)

        def getRuleIndex(self):
            return expressParser.RULE_varDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDef" ):
                listener.enterVarDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDef" ):
                listener.exitVarDef(self)




    def varDef(self):

        localctx = expressParser.VarDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_varDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1397
            self.match(expressParser.SimpleId)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarParamContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(expressParser.VAR, 0)

        def formalParam(self):
            return self.getTypedRuleContext(expressParser.FormalParamContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_varParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarParam" ):
                listener.enterVarParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarParam" ):
                listener.exitVarParam(self)




    def varParam(self):

        localctx = expressParser.VarParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_varParam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1399
            self.match(expressParser.VAR)
            self.state = 1400
            self.formalParam()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarParamsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(expressParser.VarParamContext)
            else:
                return self.getTypedRuleContext(expressParser.VarParamContext,i)


        def getRuleIndex(self):
            return expressParser.RULE_varParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarParams" ):
                listener.enterVarParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarParams" ):
                listener.exitVarParams(self)




    def varParams(self):

        localctx = expressParser.VarParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_varParams)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1402
            self.match(expressParser.T__0)
            self.state = 1403
            self.varParam()
            self.state = 1408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==expressParser.T__7:
                self.state = 1404
                self.match(expressParser.T__7)
                self.state = 1405
                self.varParam()
                self.state = 1410
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1411
            self.match(expressParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarRefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDef(self):
            return self.getTypedRuleContext(expressParser.VarDefContext,0)


        def qualifier(self):
            return self.getTypedRuleContext(expressParser.QualifierContext,0)


        def aliasRef(self):
            return self.getTypedRuleContext(expressParser.AliasRefContext,0)


        def attrRef(self):
            return self.getTypedRuleContext(expressParser.AttrRefContext,0)


        def constRef(self):
            return self.getTypedRuleContext(expressParser.ConstRefContext,0)


        def entityRef(self):
            return self.getTypedRuleContext(expressParser.EntityRefContext,0)


        def enumRef(self):
            return self.getTypedRuleContext(expressParser.EnumRefContext,0)


        def funcRef(self):
            return self.getTypedRuleContext(expressParser.FuncRefContext,0)


        def paramRef(self):
            return self.getTypedRuleContext(expressParser.ParamRefContext,0)


        def procRef(self):
            return self.getTypedRuleContext(expressParser.ProcRefContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_varRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarRef" ):
                listener.enterVarRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarRef" ):
                listener.exitVarRef(self)




    def varRef(self):

        localctx = expressParser.VarRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_varRef)
        try:
            self.state = 1434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1413
                self.varDef()
                self.state = 1414
                self.qualifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1416
                self.aliasRef()
                self.state = 1417
                self.qualifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1419
                self.attrRef()
                self.state = 1420
                self.qualifier()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1422
                self.constRef()
                self.state = 1423
                self.qualifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1425
                self.entityRef()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1426
                self.enumRef()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1427
                self.funcRef()
                self.state = 1428
                self.qualifier()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1430
                self.paramRef()
                self.state = 1431
                self.qualifier()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1433
                self.procRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileControlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(expressParser.WHILE, 0)

        def logicalExpr(self):
            return self.getTypedRuleContext(expressParser.LogicalExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_whileControl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileControl" ):
                listener.enterWhileControl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileControl" ):
                listener.exitWhileControl(self)




    def whileControl(self):

        localctx = expressParser.WhileControlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_whileControl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1436
            self.match(expressParser.WHILE)
            self.state = 1437
            self.logicalExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WidthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberExpr(self):
            return self.getTypedRuleContext(expressParser.NumberExprContext,0)


        def getRuleIndex(self):
            return expressParser.RULE_width

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWidth" ):
                listener.enterWidth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWidth" ):
                listener.exitWidth(self)




    def width(self):

        localctx = expressParser.WidthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_width)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1439
            self.numberExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





